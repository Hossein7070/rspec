<p>A key facet of the &lt;code&gt;equals&lt;/code&gt; contract is that if &lt;code&gt;a.equals(b)&lt;/code&gt; then &lt;code&gt;b.equals(a)&lt;/code&gt;, i.e. that the relationship is symmetric.</p>
<p>Using &lt;code&gt;instanceof&lt;/code&gt; breaks the contract when there are subclasses, because while the child is an &lt;code&gt;instanceof&lt;/code&gt; the parent, the parent is not an &lt;code&gt;instanceof&lt;/code&gt; the child. For instance, assume that &lt;code&gt;Raspberry extends Fruit&lt;/code&gt; and adds some fields (requiring a new implementation of &lt;code&gt;equals&lt;/code&gt;):</p>
<pre>
Fruit fruit = new Fruit();
Raspberry raspberry = new Raspberry();

if (raspberry instanceof Fruit) { ... } // true
if (fruit instanceof Raspberry) { ... } // false
</pre>
<p>If similar &lt;code&gt;instanceof&lt;/code&gt; checks were used in the classes' &lt;code&gt;equals&lt;/code&gt; methods, the symmetry principle would be broken:</p>
<pre>
raspberry.equals(fruit); // false
fruit.equals(raspberry); //true
</pre>
<p>Additionally, non &lt;code&gt;final&lt;/code&gt; classes shouldnâ€™t use a hardcoded class name in the &lt;code&gt;equals&lt;/code&gt; method because doing so breaks the method for subclasses. Instead, make the comparison dynamic.</p>
<p>Further, comparing to an unrelated class type breaks the contract for that unrelated type, because while &lt;code&gt;thisClass.equals(unrelatedClass)&lt;/code&gt; can return true, &lt;code&gt;unrelatedClass.equals(thisClass)&lt;/code&gt; will not.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Fruit extends Food {
  private Season ripe;

  public boolean equals(Object obj) {
    if (obj == this) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (Fruit.class == obj.getClass()) { // Noncompliant; broken for child classes
      return ripe.equals(((Fruit)obj).getRipe());
    }
    if (obj instanceof Fruit ) {  // Noncompliant; broken for child classes
      return ripe.equals(((Fruit)obj).getRipe());
    }
    else if (obj instanceof Season) { // Noncompliant; symmetry broken for Season class
      // ...
    }
    //...
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Fruit extends Food {
  private Season ripe;

  public boolean equals(Object obj) {
    if (obj == this) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (this.getClass() == obj.getClass()) {
      return ripe.equals(((Fruit)obj).getRipe());
    }
    return false;
}
</pre>
<h2>See</h2>
<ul>
<li><a href="https://www.securecoding.cert.org/confluence/x/zIUbAQ">CERT, MET08-J.</a> - Preserve the equality contract when overriding the equals() method</li>
</ul>
