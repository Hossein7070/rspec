<p>Casting a base-class pointer/reference to a&nbsp;derived-class pointer/reference is commonly referred to as downcasting.</p>
<p>Downcasting can only be done using an explicit cast. It is usually achieved safely using "dynamic_cast" or unsafely using "static_cast".</p>
<p>"dynamic_cast" achieve safe downcasting by performing a run-time check:</p>
<ul>
<li>If the cast memory contains an object of the expected derived type, the check succeeds. The result of the "dynamic_cast"&nbsp;points/refers to the derived object.</li>
<li>If the cast memory doesn’t contain an object of the expected derived type, the check fails. If the&nbsp;"dynamic_cast" is used on a pointer, "nullptr" is returned.&nbsp;If it was used on a reference, "std::bad_cast"&nbsp;is thrown.</li>
</ul>
<p>"static_cast" doesn’t do any runtime check; it is inherently unsafe.&nbsp;If the cast memory doesn’t contain an object of the expected derived type,&nbsp;&nbsp;your program enters the undefined behavior territory.</p>
<p>As a consequence, dynamic_cast should be preferred when downcasting.</p>
<p>Nonetheless, if you find yourself in a scenario where you want to avoid using "dynamic_cast", make sure that all the following conditions are met:</p>
<ul>
<li>You want to avoid performing run-time checks(e.g. for performance reasons).</li>
<li>You have an alternative way to guarantee that the cast memory contains an object of the expected derived type.</li>
<li>No virtual inheritance is involved.</li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
struct Shape {
  ...
};

struct Rectangle : public Shape {
  double width;
  double height;
};

struct Circle : public Shape {
  double radius;
};

double computeArea(const Shape* shape) {
  const auto* rectangle = static_cast&lt;const Rectangle*&gt;(shape); // Noncompliant
  return rectangle-&gt;width * rectangle-&gt;height;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
struct Shape {
  ...
};

struct Rectangle : public Shape {
  double width;
  double height;
};

struct Circle : public Shape {
  int radius;
};

double computeArea(const Shape* shape) {
  if(const auto* rectangle = dynamic_cast&lt;const Rectangle*&gt;(shape)) { // Compliant
    return rectangle-&gt;width * rectangle-&gt;height;
  }
  return 0;
}
</pre>
<h2>See</h2>
<ul>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/c553535fb8dda2839d13ab5f807ffbc66b63d67b/CppCoreGuidelines.md#type2-dont-use-static_cast-downcasts-use-dynamic_cast-instead">C++ Core Guidelines - Type safety profile - Type.2</a>: Don’t use static_cast to downcast. Use dynamic_cast instead.</li>
</ul>
