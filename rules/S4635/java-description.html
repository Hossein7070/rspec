<p>Looking for a given substring starting from a specified offset can be achieved by such code: &lt;code&gt;str.substring(beginIndex).indexOf(char1)&lt;/code&gt;. This works well, but it creates a new &lt;code&gt;String&lt;/code&gt; for each call to the &lt;code&gt;substring&lt;/code&gt; method. When this is done in a loop, a lot of &lt;code&gt;Strings&lt;/code&gt; are created for nothing, which can lead to performance problems if &lt;code&gt;str&lt;/code&gt; is large.</p>
<p>To avoid performance problems, &lt;code&gt;String.substring(beginIndex)&lt;/code&gt; should not be chained with the following methods:</p>
<ul>
<li>&lt;code&gt;indexOf(int ch)&lt;/code&gt;</li>
<li>&lt;code&gt;indexOf(String str)&lt;/code&gt;</li>
<li>&lt;code&gt;lastIndexOf(int ch)&lt;/code&gt;</li>
<li>&lt;code&gt;lastIndexOf(String str)&lt;/code&gt;</li>
<li>&lt;code&gt;startsWith(String prefix)&lt;/code&gt;</li>
</ul>
<p>For each of these methods, another method with an additional parameter is available to specify an offset.
Using these methods gives the same result while avoiding the creation of additional &lt;code&gt;String&lt;/code&gt; instances.</p>
<h2>Noncompliant Code Example</h2>
<pre>
str.substring(beginIndex).indexOf(char1); // Noncompliant; a new String is going to be created by "substring"
</pre>
<h2>Compliant Solution</h2>
<pre>
str.indexOf(char1, beginIndex);
</pre>
