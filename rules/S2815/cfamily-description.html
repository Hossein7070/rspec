<p>According to the C++ standard, &lt;code&gt;this&lt;/code&gt; can never be null, so comparisons of the two are pointless at best. At worst, because of compiler optimizations, such comparisons could lead to null pointer dereferences or obscure, difficult-to-diagnose errors in production.</p>
<p>This rule raises an issue when &lt;code&gt;this&lt;/code&gt; is compared to &lt;code&gt;nullptr&lt;/code&gt; or 0 or anything &lt;code&gt;#defined&lt;/code&gt; as &lt;code&gt;nullptr&lt;/code&gt; or 0, such as &lt;code&gt;NULL&lt;/code&gt; in most environments.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class MyClass {
  string name;

  string GetName() {
    if (this != 0) {  // Noncompliant
      return name;
    }
    return 0;
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class MyClass {
  string name;

  string GetName() {
    return name;
  }
}
</pre>
