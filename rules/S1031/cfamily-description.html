<p>It is undefined behaviour if, for a set of template-arguments, an implicit instantiation is generated by the compiler, and a partial or explicit specialization is declared or defined elsewhere in the program that would match the set of template-arguments.</p>
<h2>Noncompliant Code Example</h2>
<pre>
// tmpl.h
template &lt;typename T&gt; void bad_tmpl () {}

// tmpl.cc
#include "tmpl.h"
template &lt;&gt; void bad_tmpl&lt;int32_t&gt; () {} // Noncompliant, should be moved to tmpl.h

// f.cc
#include &lt;tmpl.h&gt;
void f ()
{
  bad_tmpl&lt;int32_t&gt; (); // implicit instantiation of primary. explicit instantiation in tmpl.cc would have been used if it were visible.
}
</pre>
<h2>Compliant Solution</h2>
<pre>
// tmpl.h
template &lt;typename T&gt; void good_tmpl () {}
template &lt;&gt; void bad_tmpl&lt;int32_t&gt; () {} // Compliant

// f.cc
#include &lt;tmpl.h&gt;
void f ()
{
  good_tmpl&lt;int32_t&gt; (); // specialization of good_tmpl&lt;int32_t&gt; is used
}
</pre>
<h2>See</h2>
<ul>
<li>MISRA C++:2008, 14-7-3</li>
</ul>
