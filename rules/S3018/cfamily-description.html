<p>This rule reduces confusion over which constructor will be used, and with what parameters.</p>
<h2>Noncompliant Code Example</h2>
<p>Given the following classes:</p>
<pre>
class V
{
public:
  V ( ) { }
  V ( int32_t i ) { }
};

class C1 : public virtual V
{
public:
 C1 ( ) : V ( 21 ) { }
};

class C2 : public virtual V
{
public:
  C2 ( ) : V ( 42 ) { }
};
</pre>
<p>The following examples are not compliant:</p>
<pre>
class B : public V
{
  public B( ) { } // Non-compliant - benign
}

class D: public C1, public C2
{
public:
 D ( ) { } // Non-compliant - it is unclear which constructor of V is called
};
</pre>
<h2>Compliant Solution</h2>
<p>Given the previous definitions of classes V, C1 and C2 the following definitions of B and D are compliant:</p>
<pre>
class B : public V
{
  public B( ) : V ( ) { } // Compliant
}

class D: public C1, public C2
{
public:
 D ( ) : C1 ( ), C2 ( ), V ( ) { } // Compliant
};
</pre>
<h2>See</h2>
<ul>
<li>MISRA C++:2008, 12-1-2 - All constructors of a class should explicitly call a constructor for all of its immediate base classes and all virtual base classes.</li>
</ul>
