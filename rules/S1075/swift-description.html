<p>Hard coding a URI makes it difficult to test a program: path literals are not always portable across operating systems,  a given absolute path may not exist on a specific test environment, a specified Internet URL may not be available when executing the tests, production environment filesystems usually differ from the development environment, …​etc. For all those reasons, a URI should never be hard coded. Instead, it should be replaced by customizable parameter.</p>
<p>Further even if the elements of a URI are obtained dynamically, portability can still be limited if the path-delimiters are hard-coded.</p>
<p>This rule raises an issue when URI’s or path delimiters are hard coded.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Foo {
    public func listUsers() -&gt; [User] {
        var users:[User]
        let location = "/home/mylogin/Dev/users.txt"     // Non-Compliant
        let fileContent = NSString(contentsOfFile: location, encoding: NSUTF8StringEncoding, error: nil)
        users = parse(fileContent!)
        return users
    }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Foo {
    // Configuration is a class that returns customizable properties: it can be mocked to be injected during tests.
    private var config:Configuration
    public init(myConfig:Configuration) {
        config = myConfig
    }
    public func listUsers() -&gt; [User] {
        var users:[User]
        // Find here the way to get the correct folder, in this case using the Configuration object
        let location = config.getProperty("myApplication.listingFile")
        // and use this parameter instead of the hard coded path
        let fileContent = NSString(contentsOfFile: location, encoding: NSUTF8StringEncoding, error: nil)
        users = parse(fileContent!)
        return users
    }
}
</pre>
<h2>See</h2>
<ul>
<li><a href="https://www.securecoding.cert.org/confluence/x/qQCHAQ">CERT, MSC03-J.</a> - Never hard code sensitive information</li>
</ul>
