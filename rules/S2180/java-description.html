<p>Concurrent maps are used for thread-safety, but the use of such maps alone does not ensure thread-safety; they must also be <em>used</em> in a thread-safe manner. Specifically, retrieving a key’s value from a map, and then using &lt;code&gt;put&lt;/code&gt; to add a map element if the value is &lt;code&gt;null&lt;/code&gt; is not performed in an atomic manner. Here’s what can happen</p>
<pre>
Thread1 cmap.get("key") =&gt; null
Thread2 cmap.get("key") =&gt; null
Thread1 cmap.put("key", new Value())
Thread2 cmap.put("key", new Value())
</pre>
<p>Note that this example is written as though the threads take turns performing operations, but that’s not necessarily the case.</p>
<p>Instead of &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;putIfAbsent&lt;/code&gt; should be used.</p>
<h2>Noncompliant Code Example</h2>
<pre>
private static final ConcurrentMap&lt;String,MyClass&gt; cmap = new ConcurrentHashMap&lt;String,MyClass&gt;();

public void populateMyClass(String key, String mcProp) {
  MyClass mc = cmap.get(key);
  if (mc == null) {
    mc = new MyClass();
    cmap.put(key, mc);  // Noncompliant
  }
  mc.setProp(mcProp);  // could be futile since mc may have been replaced in another thread!
}
</pre>
<h2>Compliant Solution</h2>
<pre>
private static final ConcurrentMap&lt;String,MyClass&gt; cmap = new ConcurrentHashMap&lt;String,MyClass&gt;();

public void populateMyClass(String key, String mcProp) {
  MyClass mc = cmap.get(key);
  if (mc == null) {
    mc = new MyClass();
    cmap.putIfAbsent(key, mc);
    mc = cmap.get(key); // re-retrieve value since another thread could have beaten this one to the "put"
  }
  mc.setProp(mcProp);
}
</pre>
<h2>See</h2>
<ul>
<li><a href="https://www.securecoding.cert.org/confluence/x/GQDpAQ">CERT, VNA03-J.</a> - Do not assume that a group of calls to independently atomic methods is atomic</li>
</ul>
