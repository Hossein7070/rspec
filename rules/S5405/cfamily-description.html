<p>A base class and its derived class often differ in size.
 Accessing an array of a derived class through a pointer to the base class leads to wrong pointer arithmetic and can then corrupt memory.</p>
<h2>Noncompliant Code Example</h2>
<pre>
struct Base { /*...*/};
struct Derived : public Base { /*...*/};
void f(Base const &amp;b);

int main() {
  const size_t size = 4;
  Derived derivedArray[size];
  Base* basePointer = derivedArray; // Noncompliant
  f(basePointer[2]); // The arithmetic will use the size of Base, not the size of Derived, and point to a random byte in the array
}
</pre>
<p>If you need to do a cast from derived to base in an array, do it element by element.</p>
<h2>Compliant Solution</h2>
<pre>
#include&lt;iostream&gt;

using namespace std;

struct Base {
  int iBase = 0;
};

struct Derived : public Base {
  int iDerived = 0;
};

int main() {
  const size_t size = 4;
  Derived derivedArray[size];
  for(int i=0; i&lt;size; ++i) {
    derivedArray[i].iBase = i;                                           // store : 0 1 2 3
    derivedArray[i].iDerived = i*1000;
  }
  for(int i=0; i&lt;size; ++i) {
    cout&lt;&lt;"derivedArray["&lt;&lt;i&lt;&lt;"].iBase="&lt;&lt;derivedArray[i].iBase&lt;&lt;endl;   // display : 0 1 2 3
    cout&lt;&lt;"base of derivedArray["&lt;&lt;i&lt;&lt;"].iBase="&lt;&lt;static_cast&lt;Base*&gt;(derivedArray+i)-&gt;iBase&lt;&lt;endl;     // display : 0 1 2 3
  }
  return 0;
}
</pre>
<h2>See</h2>
<ul>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#c152-never-assign-a-pointer-to-an-array-of-derived-class-objects-to-a-pointer-to-its-base">C++ Core Guidelines C.152</a>: Never assign a pointer to an array of derived class objects to a pointer to its base</li>
</ul>
