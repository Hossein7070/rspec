<p>A general &lt;code&gt;catch&lt;/code&gt; block seems like an efficient way to handle multiple possible exceptions. Unfortunately, it traps all exception types, casting too broad a net, and perhaps mishandling extraordinary cases. Instead, specific exception sub-types should be caught.</p>
<h2>Noncompliant Code Example</h2>
<pre>
try {
  file.open("test.txt");
} catch (...) {  // Noncompliant
  // ...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
try {
  file.open("test.txt");
} catch (std::ifstream::failure e) {
  // ...
}
</pre>
<h2>Exceptions</h2>
<p>There are cases though where you want to catch all exceptions, because no exceptions should be allowed to escape the function, and generic &lt;code&gt;catch&lt;/code&gt; handlers are excluded from the rule:</p>
<ul>
<li>In the main function</li>
<li>In a &lt;code&gt;noexcept&lt;/code&gt; function</li>
<li>In an &lt;code&gt;extern "C"&lt;/code&gt; function</li>
</ul>
<p>Additionally, if the &lt;code&gt;catch&lt;/code&gt; handler is throwing an exception (either the same as before, with &lt;code&gt;throw;&lt;/code&gt; or a new one that may make more sense to the callers of the function), or is never exiting (because it calls a &lt;code&gt;noreturn&lt;/code&gt; function, for instance &lt;code&gt;exit&lt;/code&gt;), then the accurate type of the exception usually does not matter any longer: this case is excluded too.</p>
