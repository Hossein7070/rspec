<p>There are several constructs in the language that work with boolean:</p>
<ul>
<li>If statements: &lt;code&gt;if (b) …​&lt;/code&gt;</li>
<li>Conditional operator: &lt;code&gt;int i = b ? 0 : 42;&lt;/code&gt;</li>
<li>Logical operators: &lt;code&gt;(b1 || b2) &amp;&amp; !b3&lt;/code&gt;</li>
</ul>
<p>Those operations would also work with arithmetic or enum values operands, because there is a conversion from those types to bool. However, this conversion might not always be obvious, for instance, an integer return code might use the value &lt;code&gt;0&lt;/code&gt; to indicate that everything worked as expected, but converted to boolean, this value would be &lt;code&gt;false&lt;/code&gt;, which often denotes failure. Conversion from integer to bool should be explicit.</p>
<p>Moreover, a logical operation with integer types might also be a confusion with the bitwise operators (&lt;code&gt;&amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;).</p>
<p>Converting a pointer to &lt;code&gt;bool&lt;/code&gt; to check if it is null is idiomatic and is allowed by this rule. We also allow the use of any user-defined type convertible to bool (for instance &lt;code&gt;std::ostream&lt;/code&gt;), since they were specifically designed to be used in such situations. What this rule really detects is the use or arithmetic types (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;…​) and of enum types.</p>
<p>On the other hand, arithmetic operations are defined with booleans, but usually make little sense (think of adding two booleans). Booleans should not be used in an arithmetic context.</p>
<p>Finally, comparing a boolean with the literals &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; is unnecessarily verbose, and should be avoided.</p>
<h2>Noncompliant Code Example</h2>
<pre>
if ( 1 &amp;&amp; ( c &lt; d ) ) // Noncompliant
if ( ( a &lt; b ) &amp;&amp; ( c + d ) ) // Noncompliant
if ( u8_a &amp;&amp; ( c + d ) ) // Noncompliant
if ( !0 ) // Noncompliant, always true
if ( !ptr ) // Compliant
if ( ( a &lt; b ) &amp;&amp; ( c &lt; d ) ) // Compliant
if ( !false ) // Compliant
if (!!a) // Compliant by exception
if ( ( a &lt; b ) == true) // Noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
if ( 1 != 0 &amp;&amp; ( c &lt; d ) ) // Compliant, but left operand is always true
if ( ( a &lt; b ) &amp;&amp; ( c + d ) != 0 ) // Compliant
if ( u8_a != 0 &amp;&amp; ( c + d ) != 0) // Compliant
if ( 0 == 0 ) // Compliant, always true
if ( a &lt; b )
</pre>
<h2>Exceptions</h2>
<p>Some people use &lt;code&gt;!!&lt;/code&gt; as a shortcut to cast an integer to bool. This usage of the &lt;code&gt;!&lt;/code&gt; operator with an integer argument is allowed for this rule.</p>
<h2>See</h2>
<ul>
<li>MISRA C:2004, 12.6 - The operands of logical operators (&amp;&amp;, || and !) should be effectively Boolean. Expressions that are effectively Boolean should not be used as operands to operators other than (&amp;&amp;, || and !).</li>
<li>MISRA C++:2008, 5-3-1 - Each operand of the ! operator, the logical &amp;&amp; or the logical || operators shall have type bool.</li>
<li><a href="https://www.securecoding.cert.org/confluence/x/KQHEAw">CERT, EXP54-J.</a> - Understand the differences between bitwise and logical operators</li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es87-dont-add-redundant—​or—​to-conditions">C++ Core Guidelines ES.87</a> - Don’t add redundant == or != to conditions</li>
</ul>
