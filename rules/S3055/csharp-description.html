<p>Synchronization can be expensive in terms of time when multiple threads need to pass through the same bottleneck (method with &lt;code&gt;\[MethodImpl(MethodImplOptions.Synchronized)\]&lt;/code&gt;).</p>
<p>If you have a piece of code calling a method with &lt;code&gt;\[MethodImpl(MethodImplOptions.Synchronized)\]&lt;/code&gt; attribute once, then it only has to wait its turn to pass through the bottleneck once. But call it in a loop, and your code has to get back in line for the bottleneck over and over.</p>
<p>Instead, it would be better to get into the bottleneck, and then do the looping. I.e. consider refactoring the code to perform the loop inside the method.</p>
<p>This rule raises an issue when a method with &lt;code&gt;\[MethodImpl(MethodImplOptions.Synchronized)\]&lt;/code&gt; is called in a loop.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public void doSomething(int max) {
  for (int i = 0; i &lt; max; i++) {
    doSynchronized(i);  // Noncompliant
  }
}

[MethodImpl(MethodImplOptions.Synchronized)]
public void doSynchronized(int val) {
  // ...
}
</pre>
