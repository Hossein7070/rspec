<p>You cannot assume that any given stream reading call will fill the &lt;code&gt;byte[]&lt;/code&gt; passed in to the method. Instead, you must check the value returned by the read method to see how many bytes were read. Fail to do so, and you introduce bug that is both harmful and difficult to reproduce.</p>
<p>Similarly, you cannot assume that &lt;code&gt;InputStream.skip&lt;/code&gt; will actually skip the requested number of bytes, but must check the value returned from the method.</p>
<p>This rule raises an issue when an &lt;code&gt;InputStream.read&lt;/code&gt; method that accepts a &lt;code&gt;byte[]&lt;/code&gt; is called, but the return value is not checked, and when the return value of &lt;code&gt;InputStream.skip&lt;/code&gt; is not checked. The rule also applies to &lt;code&gt;InputStream&lt;/code&gt; child classes.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public void doSomething(String fileName) {
  try {
    InputStream is = new InputStream(file);
    byte [] buffer = new byte[1000];
    is.read(buffer);  // Noncompliant
    // ...
  } catch (IOException e) { ... }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public void doSomething(String fileName) {
  try {
    InputStream is = new InputStream(file);
    byte [] buffer = new byte[1000];
    int count = 0;
    while (count = is.read(buffer) &gt; 0) {
      // ...
    }
  } catch (IOException e) { ... }
}
</pre>
<h2>See</h2>
<ul>
<li><a href="https://www.securecoding.cert.org/confluence/x/XACSAQ">CERT, FIO10-J.</a> - Ensure the array is filled when using read() to fill an array</li>
</ul>
