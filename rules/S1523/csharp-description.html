<p>Executing code dynamically is security-sensitive. It has led in the past to the following vulnerabilities:</p>
<ul>
<li><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-9807">CVE-2017-9807</a></li>
<li><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-9802">CVE-2017-9802</a></li>
</ul>
<p>Some APIs enable the execution of dynamic code by providing it as strings at runtime. These APIs might be useful in some very specific meta-programming use-cases. However most of the time their use is frowned upon as they also increase the risk of <a href="https://www.owasp.org/index.php/Code_Injection">Injected Code</a>. Such attacks can either run on the server or in the client (exemple: XSS attack) and have a huge impact on an application’s security.</p>
<p>This rule marks for review each occurrence of such dynamic code execution. This rule does not detect code injections. It only highlights the use of APIs which should be used sparingly and very carefully.</p>
<h2>Ask Yourself Whether</h2>
<ul>
<li>the executed code may come from an untrusted source and hasn’t been sanitized.</li>
<li>you really need to run code dynamically.</li>
</ul>
<p>There is a risk if you answered yes to any of those questions.</p>
<h2>Recommended Secure Coding Practices</h2>
<p>Regarding the execution of unknown code, the best solution is to not run code provided by an untrusted source. If you really need to do it, run the code in a <a href="https://en.wikipedia.org/wiki/Sandbox_(computer_security)">sandboxed</a> environment. Use jails, firewalls and whatever means your operating system and programming language provide (example: <a href="https://wiki.sei.cmu.edu/confluence/display/java/SEC54-J.+Create+a+secure+sandbox+using+a+security+manager">Security Managers</a> in java, <a href="https://www.w3schools.com/tags/att_iframe_sandbox.asp">iframes</a> and <a href="https://en.wikipedia.org/wiki/Same-origin_policy">same-origin policy</a> for javascript in a web browser).</p>
<p>Do not try to create a blacklist of dangerous code. It is impossible to cover all attacks that way.</p>
<p>Avoid using dynamic code APIs whenever possible. Hard-coded code is always safer.</p>
<h2>Sensitive Code Example</h2>
<pre>
using System;
using System.Reflection;

class TestReflection
{
    public static void Run(string typeName, string methodName, string fieldName, string propertyName, string moduleName)
    {
        Assembly.Load(...); // Sensitive
        Assembly.LoadFile(...); // Sensitive
        Assembly.LoadFrom(...); // Sensitive
        Assembly.LoadWithPartialName(...); // Sensitive + deprecated

        Assembly.ReflectionOnlyLoad(...);  // This is OK as the resulting type is not executable.
        Assembly.ReflectionOnlyLoadFrom(...); // This is OK as the resulting type is not executable.

        Assembly assembly = typeof(TestReflection).Assembly;

        // Review this code to make sure that the module, type, method and field are safe
        Type type = assembly.GetType(typeName); // Sensitive
        Module module = assembly.GetModule(moduleName); // Sensitive

        type = System.Type.GetType(typeName); // Sensitive
        type = type.GetNestedType(typeName); // Sensitive
        type = type.GetInterface(typeName);  // Sensitive
        MethodInfo method = type.GetMethod(methodName); // Sensitive
        FieldInfo field = type.GetField(fieldName); // Sensitive
        PropertyInfo property = type.GetProperty(propertyName); // Sensitive


        // Review this code to make sure that the modules, types, methods and fields are used safely
        Module[] modules = assembly.GetModules(); // Sensitive
        modules = assembly.GetLoadedModules(); // Sensitive

        Type[] types = assembly.GetTypes(); // Sensitive
        types = assembly.GetExportedTypes(); // Sensitive

        types = type.GetNestedTypes(); // Sensitive
        MethodInfo[] methods = type.GetMethods(); // Sensitive
        FieldInfo[] fields = type.GetFields(); // Sensitive
        PropertyInfo[] properties = type.GetProperties(); // Sensitive
        MemberInfo[] members = type.GetMembers(); // Sensitive
        members = type.GetMember(methodName); // Sensitive
        members = type.GetDefaultMembers(); // Sensitive

        type.InvokeMember(...); // Sensitive, when the method name is provided as a string

        assembly.CreateInstance(typeName); // Sensitive


        type = Type.ReflectionOnlyGetType(typeName,true, true); // This is OK as the resulting type is not executable.

        Activator.CreateComInstanceFrom(...); // Sensitive, when the type name is provided as a string
        Activator.CreateInstance(...); // Sensitive, when the type name is provided as a string
        Activator.CreateInstanceFrom(...); // Sensitive, when the type name is provided as a string
        Activator.CreateInstance&lt;&gt;(); // OK - can only be created from a referenced type
    }
}
</pre>
<h2>Exceptions</h2>
<p>No issue will be created if one of the methods above is called with a hard-coded type/method/field/property/interface/module name. There can be no injection in this specific scenario.
Example:</p>
<pre>
assembly.GetType("MyHardcodedType")
</pre>
<p>No issue will be created if one of the methods is called on an instance of <em>Type</em> created using <em>typeof</em>. There can be no injection in this specific scenario.
Example:</p>
<pre>
typeof(CustomType).GetMethods();
</pre>
<h2>See</h2>
<ul>
<li><a href="https://www.owasp.org/index.php/Top_10-2017_A1-Injection">OWASP Top 10 2017 Category A1</a> - Injection</li>
<li><a href="http://cwe.mitre.org/data/definitions/95.html">MITRE CWE-95</a> - Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')</li>
</ul>
