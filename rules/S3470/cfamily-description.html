<p>It may seem tidy to add your new declarations to the &lt;code&gt;std&lt;/code&gt; or &lt;code&gt;posix&lt;/code&gt; namespaces, but doing so results in undefined behavior. The C++14 Standard, \[namespace.std\] (ISO/IEC 14882-2014 ยง17.6.4.2.1), paragraphs 1 and 2 states:</p>
<p>{quote}</p>
<ol>
<li>The behavior of a C++ program is undefined if it adds declarations or definitions to namespace std or to a namespace within namespace std unless otherwise specified. A program may add a template specialization for any standard library template to namespace std only if the declaration depends on a user-defined type and the specialization meets the standard library requirements for the original template and is not explicitly prohibited.</li>
<li>The behavior of a C++ program is undefined if it declares:
#* an explicit specialization of any member function of a standard library class template, or
#* an explicit specialization of any member function template of a standard library class or class template, or
#* an explicit or partial specialization of any member class template of a standard library class or class template.
{quote}</li>
</ol>
<p>In addition to restricting extensions to the &lt;code&gt;std&lt;/code&gt; namespace, the C++14 Standard goes on in ยง17.6.4.2.2 to say:
{quote}</p>
<ol>
<li>The behavior of a C++ program is undefined if it adds declarations or definitions to namespace posix or to a namespace within namespace posix unless otherwise specified. The namespace posix is reserved for use by ISO/IEC 9945 and other POSIX standards.
{quote}</li>
</ol>
<p>This rule raises an issue for any modification of the standard &lt;code&gt;std&lt;/code&gt; and &lt;code&gt;posix&lt;/code&gt; namespaces.</p>
<h2>Noncompliant Code Example</h2>
<pre>
namespace std { // Noncompliant
  int x;
  void swap(MyNamespace::MyType &amp;m1, MyNamespace::MyType &amp;m2);
}
</pre>
<h2>Compliant Solution</h2>
<pre>
namespace expanded_std {
  int x;
}
namespace MyNamespace {
  void swap(MyType &amp;m1, MyType &amp;m2);
}
</pre>
<p>To override &lt;code&gt;swap&lt;/code&gt; for your own types, the override should not be placed into the namespace &lt;code&gt;std&lt;/code&gt;, but in the namespace of your type (and preferably in the same header file). Then, when you make an unqualified call to &lt;code&gt;swap&lt;/code&gt;, argument dependant lookup will ensure that your overload is found by overload resolution (as a consequence, you should never make qualified calls to &lt;code&gt;std::swap&lt;/code&gt;, because it will miss some overloads).</p>
<h2>Exceptions</h2>
<p>A namespace fragment that only contains template specializations or explicit instantiations is ignored by this rule.</p>
<h2>See</h2>
<ul>
<li><a href="https://www.securecoding.cert.org/confluence/x/LwDTAQ">CERT, DCL58-CPP.</a> - Do not modify the standard namespaces</li>
</ul>
