<p>In C, a string is just a buffer of characters, usually using the &lt;code&gt;null&lt;/code&gt; character as a sentinel for the end of the string. Which mean that the developer has to be aware of low level details such as buffer sizes, having an extra character to store the final null character…​ Doing that correctly and consistently is notoriously difficult, and any error can lead to a security vulnerability, for instance giving access to sensitive data, or allowing arbitrary code execution.</p>
<p>The function &lt;code&gt;char *strncpy(char * restrict dest, const char * restrict src, size_t count);&lt;/code&gt; copies the first &lt;code&gt;count&lt;/code&gt; characters from &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dest&lt;/code&gt;, stopping at the first null character, and filling extra space with 0. The &lt;code&gt;wcsncpy&lt;/code&gt; does the same for wide characters, and should be used with the same guidelines.</p>
<p>Both of those functions are designed to work with fixed length strings, and might result in a non null-terminated string.</p>
<h2>Ask Yourself Whether</h2>
<ul>
<li>There is a possibility that either the source or the destination pointers is null</li>
<li>The security of your system can be compromised if &lt;code&gt;dest&lt;/code&gt; is a truncated version of &lt;code&gt;source&lt;/code&gt;</li>
<li>The &lt;code&gt;source&lt;/code&gt; buffer can be both non null-terminated and smaller than count</li>
<li>The &lt;code&gt;destination&lt;/code&gt; buffer can be smaller than count</li>
<li>You expect &lt;code&gt;dest&lt;/code&gt; to be a null-terminated string</li>
<li>There is an overlap between source and destination</li>
</ul>
<p>There is a risk if you answered yes to any of those questions.</p>
<h2>Recommended Secure Coding Practices</h2>
<ul>
<li>C11 provides, in its annex K, the &lt;code&gt;strncpy_s&lt;/code&gt; and the &lt;code&gt;wcsncpy_s&lt;/code&gt; that were designed as safer alternative to &lt;code&gt;strcpy&lt;/code&gt; and &lt;code&gt;wcscpy&lt;/code&gt;. It’s not recommended to use them in all circumstances, because they introduce a runtime overhead and require to write more code for error handling, but they perform checks that will limit the consequences of calling the function with bad arguments.</li>
<li>Even if your compiler does not exactly support annex K, you probably have access to similar functions</li>
<li><p>If you are using &lt;code&gt;strncpy&lt;/code&gt; and &lt;code&gt;wsncpy&lt;/code&gt; as a safer version of &lt;code&gt;strcpy&lt;/code&gt; and &lt;code&gt;wcscpy&lt;/code&gt;, you should instead consider &lt;code&gt;strcpy_s&lt;/code&gt; and &lt;code&gt;wcscpy_s&lt;/code&gt;, because these functions have several shortcomings:</p>
<ul>
<li>It’s not easy to detect truncation</li>
<li>Too much work is done to fill the buffer with 0, leading to non optimal performances</li>
<li>Unless manually corrected, the &lt;code&gt;dest&lt;/code&gt; string might not be null-terminated</li>
</ul></li>
<li><p>If you want to use &lt;code&gt;strcpy&lt;/code&gt; and &lt;code&gt;wcscpy&lt;/code&gt; functions and detect if the string was truncated, the pattern is the following:</p>
<ul>
<li>Set the last character of the buffer to null</li>
<li>Call the function</li>
<li>Check if the last character of the buffer is still null</li>
</ul></li>
<li>If you are writing C++ code, using &lt;code&gt;std::string&lt;/code&gt; to manipulate strings is much simpler and less error-prone</li>
</ul>
<h2>Sensitive Code Example</h2>
<pre>
int f(char *src) {
  char dest[256];
  strncpy(dest, src, sizeof(dest)); // Sensitive: might silently truncate
  return doSomethingWith(dest);
}
</pre>
<h2>Compliant Solution</h2>
<pre>
int f(char *src) {
  char dest[256];
  dest[sizeof dest - 1] = 0;
  strncpy(dest, src, sizeof(dest)); // Compliant
  if (dest[sizeof dest - 1] != 0) {
    // Handle error
  }
  return doSomethingWith(dest);
}
</pre>
<h2>See</h2>
<ul>
<li><a href="http://cwe.mitre.org/data/definitions/120">MITRE, CWE-120</a> - Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')</li>
<li><a href="https://www.securecoding.cert.org/confluence/x/QwY">CERT, STR07-C.</a> - Use the bounds-checking interfaces for string manipulation</li>
</ul>
