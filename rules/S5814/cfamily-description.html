<p>In C, a string is just a buffer of characters, usually using the &lt;code&gt;null&lt;/code&gt; character as a sentinel for the end of the string. Which mean that the developer has to be aware of low level details such as buffer sizes, having an extra character to store the final null character…​ Doing that correctly and consistently is notoriously difficult, and any error can lead to a security vulnerability, for instance giving access to sensitive data, or allowing arbitrary code execution.</p>
<p>The function &lt;code&gt;char *strcat( char *restrict dest, const char *restrict src );&lt;/code&gt; appends the characters of string &lt;code&gt;src&lt;/code&gt; at the end of &lt;code&gt;dest&lt;/code&gt;. The &lt;code&gt;wcscat&lt;/code&gt; does the same for wide characters, and should be used with the same guidelines.</p>
<p>Note: the functions &lt;code&gt;strncat&lt;/code&gt; and &lt;code&gt;wcsncat&lt;/code&gt; might look like attractive safe replacements for &lt;code&gt;strcat&lt;/code&gt; and &lt;code&gt;wcscaty&lt;/code&gt;, but they have their own set of issues (see S5815), and you should probably prefer another more adapted alternative.</p>
<h2>Ask Yourself Whether</h2>
<ul>
<li>There is a possibility that either the &lt;code&gt;src&lt;/code&gt; or the &lt;code&gt;dest&lt;/code&gt; pointer is null</li>
<li>The current string length of &lt;code&gt;dest&lt;/code&gt; plus the current string length of &lt;code&gt;src&lt;/code&gt; plus 1 (for the final null character) is larger than the size of the buffer pointer-to by &lt;code&gt;src&lt;/code&gt;</li>
<li>There is a possibility that either string is not correctly null-terminated</li>
</ul>
<p>There is a risk if you answered yes to any of those questions.</p>
<h2>Recommended Secure Coding Practices</h2>
<ul>
<li>C11 provides, in its annex K, the &lt;code&gt;strcat_s&lt;/code&gt; and the &lt;code&gt;wcscat_s&lt;/code&gt; that were designed as safer alternative to &lt;code&gt;strcat&lt;/code&gt; and &lt;code&gt;wcscat&lt;/code&gt;. It’s not recommended to use them in all circumstances, because they introduce a runtime overhead and require to write more code for error handling, but they perform checks that will limit the consequences of calling the function with bad arguments.</li>
<li>Even if your compiler does not exactly support annex K, you probably have access to similar functions</li>
<li>If you are writing C++ code, using &lt;code&gt;std::string&lt;/code&gt; to manipulate strings is much simpler and less error-prone</li>
</ul>
<h2>Sensitive Code Example</h2>
<pre>
int f(char *src) {
  char dest[256];
  strcpy(dest, "Result: ");
  strcat(dest, src); // Sensitive: might overflow
  return doSomethingWith(dest);
}
</pre>
<h2>Compliant Solution</h2>
<pre>
int f(char *src) {
  char result[] = "Result: ";
  char *dest = malloc(sizeof(result) + strlen(src)); // Not need of +1 for final 0 because sizeof will already count one 0
  strcpy(dest, result);
  strcat(dest, src); // Compliant: the buffer size was carefully crafted
  int r = doSomethingWith(dest);
  free(dest);
  return r;
}
</pre>
<h2>See</h2>
<ul>
<li><a href="http://cwe.mitre.org/data/definitions/120">MITRE, CWE-120</a> - Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')</li>
<li><a href="https://www.securecoding.cert.org/confluence/x/QwY">CERT, STR07-C.</a> - Use the bounds-checking interfaces for string manipulation</li>
</ul>
