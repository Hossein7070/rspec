<p>According to the Java documentation, any implementation of the &lt;code&gt;InputSteam.read()&lt;/code&gt; method is supposed to read the next byte of data from the input stream. The value byte must be an &lt;code&gt;int&lt;/code&gt; in the range 0 to 255. If no byte is available because the end of the stream has been reached, the value -1 is returned.</p>
<p>But in Java, the &lt;code&gt;byte&lt;/code&gt; primitive data type is an 8-bit signed twoâ€™s complement integer. It has a minimum value of -128 and a maximum value of 127. So by contract, the implementation of an &lt;code&gt;InputSteam.read()&lt;/code&gt; method should never directly return a &lt;code&gt;byte&lt;/code&gt; primitive data type. A conversion into an unsigned byte must be done before by applying a bitmask.</p>
<h2>Noncompliant Code Example</h2>
<pre>
@Override
public int read() throws IOException {
  if (pos == buffer.length()) {
    return -1;
  }
  return buffer.getByte(pos++); // Noncompliant, a signed byte value is returned
}
</pre>
<h2>Compliant Solution</h2>
<pre>
@Override
public int read() throws IOException {
  if (pos == buffer.length()) {
    return -1;
  }
  return buffer.getByte(pos++) &amp; 0xFF; // The 0xFF bitmask is applied
}
</pre>
