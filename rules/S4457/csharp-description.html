<p>Because of the way &lt;code&gt;async/await&lt;/code&gt; methods are rewritten by the compiler, any exceptions thrown during the parameters check will happen only when the task is observed. That could happen far away from the source of the buggy code or never happen for fire-and-forget tasks.</p>
<p>Therefore it is recommended to split the method into two: an outer method handling the parameter checks (without being &lt;code&gt;async/await&lt;/code&gt;) and an inner method to handle the iterator block with the &lt;code&gt;async/await&lt;/code&gt; pattern.</p>
<p>This rule raises an issue when an &lt;code&gt;async&lt;/code&gt; method throws any exception derived from &lt;code&gt;ArgumentException&lt;/code&gt; and contains &lt;code&gt;await&lt;/code&gt; keyword.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public static async Task SkipLinesAsync(this TextReader reader, int linesToSkip) // Noncompliant
{
    if (reader == null) { throw new ArgumentNullException(nameof(reader)); }
    if (linesToSkip &lt; 0) { throw new ArgumentOutOfRangeException(nameof(linesToSkip)); }

    for (var i = 0; i &lt; linesToSkip; ++i)
    {
        var line = await reader.ReadLineAsync().ConfigureAwait(false);
        if (line == null) { break; }
    }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public static Task SkipLinesAsync(this TextReader reader, int linesToSkip)
{
    if (reader == null) { throw new ArgumentNullException(nameof(reader)); }
    if (linesToSkip &lt; 0) { throw new ArgumentOutOfRangeException(nameof(linesToSkip)); }

    return reader.SkipLinesInternalAsync(linesToSkip);
}

private static async Task SkipLinesInternalAsync(this TextReader reader, int linesToSkip)
{
    for (var i = 0; i &lt; linesToSkip; ++i)
    {
        var line = await reader.ReadLineAsync().ConfigureAwait(false);
        if (line == null) { break; }
    }
}
</pre>
