<p>An implicit template specialization does not instantiate every member of the template. Where instantiation of a member would result in an ill-formed program it is not clear that the template should be used with the supplied template-arguments.</p>
<h2>Noncompliant Code Example</h2>
<pre>
template &lt;typename T&gt;
class A
{
public:
  void f1 ()
  {
    // ...
  }
  void f2 ()
  {
    T t;
    t.x = 0; // Will only work for types that have a .x member
  }
};

void b ()
{
  A&lt;int32_t&gt; a; // A&lt;int32_t&gt;::f2 is not instantiated.
  a.f1 ();
}

template class A&lt;int32_t&gt;; // Noncompliant, instantiation of f2 results in "ill-formed" program.
</pre>
<h2>See</h2>
<ul>
<li>MISRA C++:2008, 14-7-2</li>
</ul>
