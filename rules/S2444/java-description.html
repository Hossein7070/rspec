<p>In a multi-threaded situation, un-&lt;code&gt;synchronized&lt;/code&gt; lazy initialization of static fields could mean that a second thread has access to a half-initialized object while the first thread is still creating it. Allowing such access could cause serious bugs. Instead. the initialization block should be &lt;code&gt;synchronized&lt;/code&gt;.</p>
<p>Similarly, updates of such fields should also be &lt;code&gt;synchronized&lt;/code&gt;.</p>
<p>This rule raises an issue whenever a lazy static initialization is done on a class with at least one &lt;code&gt;synchronized&lt;/code&gt; method, indicating intended usage in multi-threaded applications.</p>
<h2>Noncompliant Code Example</h2>
<pre>
private static Properties fPreferences = null;

private static Properties getPreferences() {
        if (fPreferences == null) {
            fPreferences = new Properties(); // Noncompliant
            fPreferences.put("loading", "true");
            fPreferences.put("filterstack", "true");
            readPreferences();
        }
        return fPreferences;
    }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
private static Properties fPreferences = null;

private static synchronized Properties getPreferences() {
        if (fPreferences == null) {
            fPreferences = new Properties();
            fPreferences.put("loading", "true");
            fPreferences.put("filterstack", "true");
            readPreferences();
        }
        return fPreferences;
    }
}
</pre>
