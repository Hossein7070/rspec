<p>Using &lt;code&gt;FORALL i IN x.first …​ x&lt;/code&gt;.last or &lt;code&gt;FORALL i IN 1 …​ x.count&lt;/code&gt; might fail when indexed collections are sparse as Oracle tries to access non-existent element(s) of x. &lt;code&gt;FORALL i IN INDICES OF x&lt;/code&gt; syntax will always work including sparse collections. Thus using &lt;code&gt;FORALL i IN INDICES OF x&lt;/code&gt; should be preferred as it makes code more robust and easier to review.</p>
<h2>Noncompliant Code Example</h2>
<pre>
FORALL i IN 1 .. l_tab.COUNT  -- Non-Compliant
    INSERT INTO forall_test VALUES l_tab(i);

FORALL i IN l_tab.first .. l_tab.last  -- Non-Compliant
    INSERT INTO forall_test VALUES l_tab(i);
</pre>
<h2>Compliant Solution</h2>
<pre>
FORALL i IN INDICES OF l_tab
    INSERT INTO forall_test VALUES l_tab(i);
</pre>
<h2>See</h2>
<ul>
<li><a href="https://blogs.oracle.com/oraclemagazine/oracle-10g-adds-more-to-forall">Oracle 10g Adds More to FORALL</a></li>
<li><a href="https://stevenfeuersteinonplsql.blogspot.com/2019/03/using-sparse-collections-with-forall.html">Using sparse collections with FORALL</a> - Steven Feuerstein</li>
</ul>
