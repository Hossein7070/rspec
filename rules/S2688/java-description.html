<p>When working with &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt; primitive types, it may be required to deal with &lt;code&gt;NaN&lt;/code&gt; (Not a Number) values. When tested against itself, &lt;code&gt;NaN&lt;/code&gt; will always answer &lt;code&gt;false&lt;/code&gt; as long as the primitive wrapper type is not used. When the wrapper is used, it will always be &lt;code&gt;true&lt;/code&gt;. This property is illustrated in the code snipped below.</p>
<pre>
double d = getValue();
if (d == d) { // false for primitive 'double' when NaN, and true for any non-NaN values
  doSomething();
}

Double bigD = getValue();
if (bigD == bigD) { // always true for wrapper type 'Double' when NaN, AND with any other Double value
  doSomething();
}
</pre>
<p>In order to remove any ambiguity, this rule raises an issue every time an equality test is used with &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;Float&lt;/code&gt;, when both sides of the test are the same variable. The &lt;code&gt;isNaN(…​)&lt;/code&gt; methods from &lt;code&gt;Double&lt;/code&gt; and &lt;code&gt;Float&lt;/code&gt; should be preferred.</p>
<h2>Noncompliant Code Example</h2>
<pre>
double x = getValue();
if (x == x) { // Noncompliant
  doSomething();
}
if (x == Double.NaN) { // Noncompliant
  doSomething();
}
</pre>
<h2>Compliant Solution</h2>
<pre>
double x = getValue();
if (Double.isNaN(x)) { // compliant
  doSomething();
}
</pre>
<h2>See</h2>
<ul>
<li><a href="https://www.securecoding.cert.org/confluence/x/7AEqAQ">CERT, NUM07-J.</a> - Do not attempt comparisons with NaN</li>
</ul>
