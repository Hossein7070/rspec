<p>Making a &lt;code&gt;base&lt;/code&gt; call in an overriding method is generally a good idea, but not in &lt;code&gt;GetHashCode&lt;/code&gt; and &lt;code&gt;Equals&lt;/code&gt; for classes that directly extend &lt;code&gt;object&lt;/code&gt; because those methods are based on the object reference. Meaning that no two &lt;code&gt;objects&lt;/code&gt; that use those &lt;code&gt;base&lt;/code&gt; methods will ever be equal or have the same hash.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Point
{
  private readonly int x;
  public MyClass(int x)
  {
    this.x = x;
  }
  public override int GetHashCode()
  {
    return x.GetHashCode() ^ base.GetHashCode(); //Noncompliant
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Point
{
  private readonly int x;
  public MyClass(int x)
  {
    this.x = x;
  }
  public override int GetHashCode()
  {
    return x.GetHashCode();
  }
}
</pre>
<h2>Exceptions</h2>
<p>This rule doesnâ€™t report on guard conditions checking for reference equality.</p>
<pre>
public class Point
{
  public override bool Equals(object obj)
  {
    if (base.Equals(obj)) // Compliant, although it could be replaced with object.ReferenceEquals(obj, this), which is clearer
    {
      return true;
    }
    ...
  }
}
</pre>
