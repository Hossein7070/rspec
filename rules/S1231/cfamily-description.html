<p>The &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;realloc&lt;/code&gt;, &lt;code&gt;calloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; routines are used to dynamically allocate memory in the heap. But, in contrast to the &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; operators introduced in C++, they allocate raw memory, which is not type-safe, and they do not correctly invoke object constructors. Additionally, mixing them with &lt;code&gt;new&lt;/code&gt;/&lt;code&gt;delete&lt;/code&gt; results in undefined behavior.</p>
<p>Note that directly replacing those functions with &lt;code&gt;new&lt;/code&gt;/&lt;code&gt;delete&lt;/code&gt; is usually not a good idea (see S5025).</p>
<h2>Noncompliant Code Example</h2>
<pre>
string* pStringArray1 = static_cast&lt;string*&gt;(malloc(10 * sizeof(string))); // Noncompliant
Person *p = (Person*)malloc(sizeof(Person)); // Noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
std::array&lt;string, 10&gt; stringArray1 ; // Compliant, use std::vector instead if the size is dynamic
auto p1 = new Person("Bjarne"); // Compliant, but don't do that, prefer the version on next line
auto p2 = std::make_unique&lt;Person&gt;("Bjarne"); // Compliant
</pre>
<h2>See</h2>
<ul>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#r10-avoid-malloc-and-free">C++ Core Guidelines R.10</a> Avoid malloc() and free()</li>
</ul>
