<p>&lt;code&gt;ThreadLocal&lt;/code&gt; variables are supposed to be garbage collected once the holding thread is no longer alive. Memory leaks can occur when holding threads are re-used which is the case on application servers using pool of threads.
To avoid such problems, it is recommended to always clean up &lt;code&gt;ThreadLocal&lt;/code&gt; variables using the &lt;code&gt;remove()&lt;/code&gt; method to remove the current threadâ€™s value for the &lt;code&gt;ThreadLocal&lt;/code&gt; variable.</p>
<p>In addition, calling &lt;code&gt;set(null)&lt;/code&gt; to remove the value might keep the reference to &lt;code&gt;this&lt;/code&gt; pointer in the map, which can cause memory leak in some scenarios. Using &lt;code&gt;remove&lt;/code&gt; is safer to avoid this issue.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class ThreadLocalUserSession implements UserSession {

  private static final ThreadLocal&lt;UserSession&gt; DELEGATE = new ThreadLocal&lt;&gt;();

  public UserSession get() {
    UserSession session = DELEGATE.get();
    if (session != null) {
      return session;
    }
    throw new UnauthorizedException("User is not authenticated");
  }

  public void set(UserSession session) {
    DELEGATE.set(session);
  }

   public void incorrectCleanup() {
     DELEGATE.set(null); // Noncompliant
   }

  // some other methods without a call to DELEGATE.remove()
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class ThreadLocalUserSession implements UserSession {

  private static final ThreadLocal&lt;UserSession&gt; DELEGATE = new ThreadLocal&lt;&gt;();

  public UserSession get() {
    UserSession session = DELEGATE.get();
    if (session != null) {
      return session;
    }
    throw new UnauthorizedException("User is not authenticated");
  }

  public void set(UserSession session) {
    DELEGATE.set(session);
  }

  public void unload() {
    DELEGATE.remove(); // Compliant
  }

  // ...
}
</pre>
<h2>Exceptions</h2>
<p>Rule will not detect non-private &lt;code&gt;ThreadLocal&lt;/code&gt; variables, because &lt;code&gt;remove()&lt;/code&gt; can be called from another class.</p>
<h2>See</h2>
<ul>
<li><a href="https://www.baeldung.com/java-memory-leaks">Understanding Memory Leaks in Java</a></li>
</ul>
