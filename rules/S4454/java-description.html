<p>By contract, the &lt;code&gt;equals(Object)&lt;/code&gt; method, from &lt;code&gt;java.lang.Object&lt;/code&gt;, should accept a &lt;code&gt;null&lt;/code&gt; argument. Among all the other cases, the &lt;code&gt;null&lt;/code&gt; case is even explicitly detailed in the &lt;code&gt;Object.equals(…​)&lt;/code&gt; Javadoc, stating "<em>For any non-null reference value x, x.equals(null) should return false.</em>"</p>
<p>Assuming that the argument to &lt;code&gt;equals&lt;/code&gt; is always non-null, and enforcing that assumption with an annotation is not only a fundamental violation of the contract of &lt;code&gt;equals&lt;/code&gt;, but it is also likely to cause problems in the future as the use of the class evolves over time.</p>
<p>The rule raises an issue when the &lt;code&gt;equals&lt;/code&gt; method is overridden and its parameter annotated with any kind of &lt;code&gt;@Nonnull&lt;/code&gt; annotation.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public boolean equals(@javax.annotation.Nonnull Object obj) { // Noncompliant
  // ...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public boolean equals(Object obj) {
  if (obj == null) {
    return false;
  }
  // ...
}
</pre>
