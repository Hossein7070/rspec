<p><em>Mutexes</em> are synchronization primitives that allow to manage concurrency using a mechanism of &lt;code&gt;lock&lt;/code&gt;/&lt;code&gt;unlock&lt;/code&gt;.
While explicitly locking or unlocking a <em>mutex</em> is possible, it is error prone. And this is particularly true in complex code paths (or with exceptions) where it is easy to have a mismatch between &lt;code&gt;lock&lt;/code&gt;s and &lt;code&gt;unlock&lt;/code&gt;s.
As a result, <em>mutexes</em> should not be locked or unlocked manually.</p>
<p>Adopting the C++ RAII idiom solves this problem by creating an object that will lock the <em>mutex</em> on creation and unlock it on destruction. Furthermore, using this idiom can also greatly improve the readability of the code.</p>
<p>Several classes are available as RAII wrappers:</p>
<ul>
<li>&lt;code&gt;std::scoped_lock&lt;/code&gt; is the default, most efficient wrapper for simple cases (only available since C++17)</li>
<li>&lt;code&gt;std::lock_guard&lt;/code&gt; is similar to &lt;code&gt;std::scoped_lock&lt;/code&gt;, but with less features. It should only be used if you donâ€™t have access to &lt;code&gt;std::scoped_lock&lt;/code&gt;.</li>
<li>&lt;code&gt;std::unique_lock&lt;/code&gt; allows more manual unlocking/locking again, and should only be used when these features are needed, for instance with condition variables.</li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
#include &lt;mutex&gt;

class DataItem;

class DataStore {
public:
  bool store(const DataItem &amp;dataItem);
  bool has(const DataItem &amp;dataItem);
};

DataStore sharedDataStore;
std::mutex sharedDataStoreMutex;

bool storeIfRelevantInSharedContext(const DataItem &amp;dataItem) {
  sharedDataStoreMutex.lock(); // Noncompliant
  if (sharedDataStore.has(dataItem)) {
    sharedDataStoreMutex.unlock(); // Noncompliant
    return false;
  }
  bool result = sharedDataStore.store(dataItem);
  sharedDataStoreMutex.unlock(); // Noncompliant
  return result;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
#include &lt;mutex&gt;

class DataItem;

class DataStore {
public:
  bool store(const DataItem &amp;dataItem);
  bool has(const DataItem &amp;dataItem);
};

DataStore sharedDataStore;
std::mutex sharedDataStoreMutex;

bool storeIfRelevantInSharedContext(const DataItem &amp;dataItem) {
  std::scoped_lock&lt;std::mutex&gt; lock(sharedDataStoreMutex);
  if (sharedDataStore.has(dataItem)) {
    return false;
  }
  return sharedDataStore.store(dataItem);
}
</pre>
<h2>See</h2>
<ul>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#cp20-use-raii-never-plain-lockunlock">C++ Core Guidelines - CP.20</a> - Use RAII, never plain lock()/unlock()</li>
</ul>
