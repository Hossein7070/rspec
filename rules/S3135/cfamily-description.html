<p>&lt;code&gt;sizeof&lt;/code&gt; returns the size in bytes of a type. &lt;code&gt;alignof&lt;/code&gt; (since C++-11) returns the alignment, in bytes, required for any instance of a type. Using any other kind of value with &lt;code&gt;sizeof&lt;/code&gt;, or &lt;code&gt;alignof&lt;/code&gt;, is likely a mistake - what is returned is the size, or alignment, of the operand’s type.</p>
<p>This rule raises issues for the following &lt;code&gt;sizeof&lt;/code&gt;, and &lt;code&gt;alignof&lt;/code&gt; calls:</p>
<ul>
<li>with parameters that have a &lt;code&gt;void&lt;/code&gt; type. That is forbidden by both the C and C++ standards</li>
<li>on a pointer type variable. This is typically a mistake; usually the intent is to get the size, or alignment, of the pointed-to value instead</li>
<li>when the parameter is another &lt;code&gt;sizeof&lt;/code&gt;, or &lt;code&gt;alignof&lt;/code&gt; call. &lt;code&gt;sizeof(sizeof(…​))&lt;/code&gt; indicates a misuse or misunderstanding of the &lt;code&gt;sizeof&lt;/code&gt; construct</li>
<li>when side effects are intended in the parameter. The side effects don’t actually occur; the expression is not evaluated because &lt;code&gt;sizeof&lt;/code&gt; only acts on the type of the expression</li>
<li>when there are calculations within &lt;code&gt;sizeof&lt;/code&gt;, or &lt;code&gt;alignof&lt;/code&gt;; the result will be &lt;code&gt;sizeof(int)&lt;/code&gt;, or &lt;code&gt;alignof(int)&lt;/code&gt;, assuming the calculation’s operands are &lt;code&gt;int&lt;/code&gt;s</li>
<li>when numeric constants are used with &lt;code&gt;sizeof&lt;/code&gt; or &lt;code&gt;alignof&lt;/code&gt;. Such calls simply return &lt;code&gt;sizeof(int)&lt;/code&gt; or &lt;code&gt;alignof(int)&lt;/code&gt; respectively.</li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
void fun(int array[10]) {
  int length = 42;

  for (size_t i = 0; i &lt; sizeof(array) / sizeof(*array); i++) { // Noncompliant, type of array decays to int *, so sizeof(array) evaluates to sizeof(int *)
    array[i] = 0;
  }

  size_t size = sizeof(i = 1234); // Noncompliant, side effect
  size = sizeof(i++); // Noncompliant, side effect

  size = sizeof(sizeof(i)); // Noncompliant, one sizeof call was intended

  char *cp = malloc(sizeof(length + 1));  // Noncompliant, calculation in parameter

  size = sizeof(10); // Noncompliant, constant as parameter

  void* p;
  alignof(*p);  // Noncompliant, void type
  alignof(void);  // Noncompliant, void type
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void fun(int array[10]) {
  int length = 42;

  for (size_t i = 0; i &lt; count; i++) {
    array[i] = 0;
  }

  int i = 1234;
  size_t size = sizeof( i );
  i++;
  size = sizeof (i);

  size = sizeof(i);

  char *cp = malloc((length + 1) * sizeof(char));

  size = sizeof(int);
}
</pre>
<h2>See</h2>
<ul>
<li>MISRA C:2004, 12.3 - The sizeof operator shall not be used on expressions that contain side effects.</li>
<li>MISRA C++:2008, 5-3-4 - Evaluation of the operand to the sizeof operator shall not contain side effects.</li>
<li>MISRA C:2012, 13.6 - The operand of the sizeof operator shall not contain any expression which has potential side effects</li>
<li><a href="https://www.securecoding.cert.org/confluence/x/6wE">CERT, ARR01-C.</a> - Do not apply the &lt;code&gt;sizeof&lt;/code&gt; operator to a pointer when taking the size of an array</li>
<li><a href="https://www.securecoding.cert.org/confluence/x/LQo">CERT, EXP44-C.</a> - Do not rely on side effects in operands to &lt;code&gt;sizeof&lt;/code&gt;, &lt;code&gt;_Alignof&lt;/code&gt;, or &lt;code&gt;_Generic&lt;/code&gt;</li>
<li><a href="https://www.securecoding.cert.org/confluence/x/KYDxC">CERT, EXP52-CPP.</a> - Do not rely on side effects in unevaluated operands</li>
<li><a href="http://cwe.mitre.org/data/definitions/467">MITRE, CWE-467</a> - Use of sizeof() on a Pointer Type</li>
</ul>
