<p>The basic numeric types &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt; should not be used. Instead, specific-length typedefs should be. This rule helps to clarify the size of the storage, but does not guarantee portability because of the asymmetric behavior of integral promotion.</p>
<p>Note that it is still important to understand the integer size of the implementation, and developers should be aware of the actual implementation of the typedefs under these definitions.</p>
<h2>Noncompliant Code Example</h2>
<pre>
int function(unsigned short a) // Noncompliant
{
  // ...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
#include &lt;stdint.h&gt;
int32_t function(uint16_t a) // Compliant
{
  // ...
}
</pre>
<h2>See</h2>
<ul>
<li>MISRA C:2004, 6.3 - typedefs that indicate size and signedness should be used in place of the basic types</li>
<li>MISRA C++:2008, 3-9-2 - typedefs that indicate size and signedness should be used in place of the basic numerical types</li>
</ul>
<h3>See Also</h3>
<ul>
<li>MISRA C++ 2008 Section 6.5.0 on integral promotion</li>
</ul>
