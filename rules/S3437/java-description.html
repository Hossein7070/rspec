<p>According to the documentation,
bq. A program may produce unpredictable results if it attempts to distinguish two references to equal values of a value-based class, whether directly via reference equality or indirectly via an appeal to synchronization, identity hashing, serialization…​</p>
<p>For example (credit to Brian Goetz), imagine Foo is a value-based class:</p>
<pre>
Foo[] arr = new Foo[2];
arr[0] = new Foo(0);
arr[1] = new Foo(0);
</pre>
<p>Serialization promises that on deserialization of arr, elements 0 and 1 will not be aliased.  Similarly, in:</p>
<pre>
Foo[] arr = new Foo[2];
arr[0] = new Foo(0);
arr[1] = arr[0];
</pre>
<p>Serialization promises that on deserialization of &lt;code&gt;arr&lt;/code&gt;, elements 0 and 1 <strong>will</strong> be aliased.</p>
<p>While these promises are coincidentally fulfilled in current implementations of Java, that is not guaranteed in the future, particularly when true value types are introduced in the language.</p>
<p>This rule raises an issue when a &lt;code&gt;Serializable&lt;/code&gt; class defines a non-transient, non-static field field whose type is a known serializable value-based class. Known serializable value-based classes are: all the classes in the &lt;code&gt;java.time&lt;/code&gt; package except &lt;code&gt;Clock&lt;/code&gt;; the date classes for alternate calendars: &lt;code&gt;HijrahDate&lt;/code&gt;, &lt;code&gt;JapaneseDate&lt;/code&gt;, &lt;code&gt;MinguoDate&lt;/code&gt;, &lt;code&gt;ThaiBuddhistDate&lt;/code&gt;.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class MyClass implements Serializable {
  private HijrahDate date;  // Noncompliant; mark this transient
  // ...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class MyClass implements Serializable {
  private transient HijrahDate date;
  // ...
}
</pre>
<h2>See</h2>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/doc-files/ValueBased.html">Value-based classes</a></li>
</ul>
