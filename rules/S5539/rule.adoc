Batch Apex jobs should execute as fast as possible because other jobs wait in the queue. They will execute faster when their <code>start</code> method returns a QueryLocator object or an iterable which does not use subqueries to include related records. It is more efficient to execute these subqueries separately inside the <code>execute</code> method of the Batch class.

This rule raises an issue when, in the context of a Batch class' <code>start</code> method, the  <code>Database.getQueryLocator(query)</code> method is called with a query containing one or more subqueries


== Noncompliant Code Example

----
global class MyBatch implements Database.Batchable<sObject> {
    global MyBatch(){
    }

    global Database.QueryLocator start(Database.BatchableContext BC){
        return Database.getQueryLocator([SELECT Id, (SELECT id FROM Contacts) FROM Account]);  // Noncompliant
    }

    global void execute(Database.BatchableContext BC, List<sObject> scope){
        // ...
    }

    global void finish(Database.BatchableContext BC){
        // ...
    }
}
----


== See

* https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_batch_interface.htm[Using Batch Apex] (See the "Batch Apex Best Practices" section)

