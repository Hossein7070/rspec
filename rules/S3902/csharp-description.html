<p>Using &lt;code&gt;Type.Assembly&lt;/code&gt; to get the current assembly is nearly free in terms of performance; itâ€™s a simple property access. On the other hand, &lt;code&gt;Assembly.GetExecutingAssembly()&lt;/code&gt; can take up to 30 times as long because it walks up the call stack to find the assembly.</p>
<p>Note that &lt;code&gt;Assembly.GetExecutingAssembly()&lt;/code&gt; is different than &lt;code&gt;Type.Assembly&lt;/code&gt; because it dynamically returns the assembly that contains the startup object of the currently executed application. For example, if executed from an application it will return the application assembly, but if executed from a unit test project it could return the unit test assembly. &lt;code&gt;Type.Assembly&lt;/code&gt; always returns the assembly that contains the specified type.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Example
{
   public static void Main()
   {
      Assembly assem = Assembly.GetExecutingAssembly(); // Noncompliant
      Console.WriteLine("Assembly name: {0}", assem.FullName);
   }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Example
{
   public static void Main()
   {
      Assembly assem = typeof(Example).Assembly; // Here we use the type of the current class
      Console.WriteLine("Assembly name: {0}", assem.FullName);
   }
}
</pre>
