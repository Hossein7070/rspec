<p>Primitives can be read and written to atomically. Except for &lt;code&gt;long&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt;, that is. These 64-bit primitives must be marked &lt;code&gt;volatile&lt;/code&gt; in multi-threaded environments, or swapped out for their atomic counterparts: &lt;code&gt;AtomicLong&lt;/code&gt;, and &lt;code&gt;AtomicDouble&lt;/code&gt; to guarantee that their updates are always visible to other threads.</p>
<p>Similarly, to ensure that updates to 32-bit primitives are visible to all threads, they should also be marked &lt;code&gt;volatile&lt;/code&gt;.</p>
<h2>Noncompliant Code Example</h2>
<pre>
long m = 0;  // Noncompliant

public void increment() {
  m++;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
volatile long m = 0;

public void increment() {
  m++;
}
</pre>
<p>or</p>
<pre>
AtomicLong m = new AtomicLong(0);

public void increment() {
  m.incrementAndGet();
}
</pre>
<h2>See</h2>
<ul>
<li><a href="https://www.securecoding.cert.org/confluence/x/PoFJAg">CERT, VNA00-J.</a> - Ensure visibility when accessing shared primitive variables</li>
<li><a href="https://www.securecoding.cert.org/confluence/x/8IBBAg">CERT, VNA05-J.</a> - Ensure atomicity when reading and writing 64-bit values</li>
</ul>
