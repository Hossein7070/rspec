<p>Contrary to possible developer expectations, a template constructor will not suppress the compiler-generated copy constructor. This may lead to incorrect copy semantics for members requiring deep copies.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class A
{
public:
  A ( );
  // A ( A const &amp; rhs ); Example 1 - implicitly generated
  template &lt;typename T&gt;
  A ( T const &amp; rhs ) // Example 2
  : i ( new int32_t )
  {
   *i = *rhs.i;
  }
private:
  int32_t * i; // Member requires deep copy
};

void f ( A const &amp; a1 )
{
  A a2 ( a1 ); // Noncompliant, unexpectedly uses Example 1, which will result in a shallow copy of 'i', instead of a deep copy
}
</pre>
<h2>See</h2>
<ul>
<li>MISRA C++:2008, 14-5-2</li>
</ul>
