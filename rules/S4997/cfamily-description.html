<p>&lt;code&gt;std::auto_ptr&lt;/code&gt; was a pre-C++11 attempt to do what &lt;code&gt;std::unique_ptr&lt;/code&gt; now does. Unfortunately, the move semantics needed to make it work properly werenâ€™t in place, so copying a &lt;code&gt;std::auto_ptr&lt;/code&gt; has the very surprising behavior of invalidating the source of the copy.</p>
<p>That problem has been fixed with &lt;code&gt;std::unique_ptr&lt;/code&gt;, so &lt;code&gt;std::auto_ptr&lt;/code&gt; has been deprecated in C11 and removed in C17.</p>
<p>If your compiler allows it, you should replace all use of &lt;code&gt;std::auto_ptr&lt;/code&gt; with &lt;code&gt;std::unique_ptr&lt;/code&gt;. Otherwise, define your own (non-copyable) smart pointer.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using namespace std;

void draw(auto_ptr&lt;Shape&gt; p) { cout &lt;&lt; s-&gt;x() &lt;&lt; ", " &lt;&lt; s.y() &lt;&lt; endl;} // Noncompliant

void f()
{
    std::auto_ptr&lt;Shape&gt; s = createShape(); // Noncompliant
    draw(s); // This call invalidates s
    draw(s); // This call will crash, because s is null
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using namespace std;

void draw(unique_ptr&lt;Shape&gt; p) { cout &lt;&lt; s-&gt;x() &lt;&lt; ", " &lt;&lt; s.y() &lt;&lt; endl;} // Compliant

void f()
{
    std::unique_ptr&lt;Shape&gt; s = createShape();
    // draw(s); // Would not compile
    draw(move(s)); // Will compile, and the user knows s has been invalidated
}
</pre>
