<p>Floating point math is imprecise because of the challenges of storing such values in a binary representation. Even worse, floating point math is not associative; push a &lt;code&gt;Float&lt;/code&gt; or a &lt;code&gt;Double&lt;/code&gt; through a series of simple mathematical operations and the answer will be different based on the order of those operation because of the rounding that takes place at each step.</p>
<p>Even simple floating point assignments are not simple:</p>
<pre>
var f: Float = 0.1 // 0.1000000014901161193847656
var d: Double = 0.1 // 0.1000000000000000055511151
</pre>
<p>Therefore, the use of the equality (&lt;code&gt;==&lt;/code&gt;) and inequality (&lt;code&gt;!=&lt;/code&gt;) operators on &lt;code&gt;Float&lt;/code&gt; or &lt;code&gt;Double&lt;/code&gt; values is almost always an error.</p>
<p>This rule checks for the use of direct and indirect equality/inequailty tests on floats and doubles.</p>
<h2>Noncompliant Code Example</h2>
<pre>
var myNumber: Float = 0.3 + 0.6

if myNumber == 0.9 { // Noncompliant. Because of floating point imprecision, this will be false
    // ...
}

if myNumber &lt;= 0.9 &amp;&amp; myNumber &gt;= 0.9 { // Noncompliant indirect equality test
  // ...
}

if myNumber &lt; 0.9 || myNumber &gt; 0.9 { // Noncompliant indirect inequality test
  // ...
}
</pre>
