<p>For loops are a very powerful and versatile tool that can be used for many purposes. This flexibility comes with drawbacks:</p>
<ul>
<li>It is very easy to make a small mistake when writing them,</li>
<li>They are relatively verbose to write,</li>
<li>They do not express the intent of the code, the reader has to look at loop details to understand what the loop does.</li>
</ul>
<p>There are algorithms that encapsulate a &lt;code&gt;for&lt;/code&gt; loop and give it some meaning (&lt;code&gt;std::all_of&lt;/code&gt;, &lt;code&gt;std::count_if&lt;/code&gt;, &lt;code&gt;std::remove_if&lt;/code&gt;…​). These algorithms are well tested, efficient and explicit and therefore should be your first choice.</p>
<p>If you just want to iterate on all elements of a sequence, you have two options:</p>
<ul>
<li>Range-based for loops, which were introduced in C++11 and will run through all elements of a sequence</li>
<li>&lt;code&gt;std::for_each&lt;/code&gt;, an algorithm that performs the same operation between two iterators (allowing more flexibility, for instance by using &lt;code&gt;reverse_iterator&lt;/code&gt;s, or with a variant that can loop in parallel on several elements at a time).</li>
</ul>
<p>This rule raises an issue when a &lt;code&gt;for&lt;/code&gt;-loop goes through all consecutive elements of a sequence (eg: containers, objects with begin() and end() member functions), and deals only with the current element without side-effects on the rest of the sequence.</p>
<h2>Noncompliant Code Example</h2>
<pre>
#include &lt;vector&gt;
#include &lt;iostream&gt;

using namespace std;

int f(vector&lt;int&gt; &amp;v) {

  for (auto it = v.begin(); it != v.end(); ++it) { // Noncompliant
    if (*it &gt; 0) {
      cout &lt;&lt; "Positive number : " &lt;&lt; *it &lt;&lt; endl;
    } else {
      cout &lt;&lt; "Negative number : " &lt;&lt; *it &lt;&lt; endl;
    }
  }

  auto sum = 0;
  for (auto it = v.begin(); it != v.end(); ++it) { // Noncompliant
    sum += *it;
  }
  return sum;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

void displayNumber(int i) {
  if (i &gt; 0) {
    cout &lt;&lt; "Positive number : " &lt;&lt; i &lt;&lt; endl;
  } else {
    cout &lt;&lt; "Negative number : " &lt;&lt; i &lt;&lt; endl;
  }
}

void f(vector&lt;int&gt; &amp;v) {

  for_each(v.begin(), v.end(), displayNumber);

  auto sum = 0;
  for (auto elt : v) {
    sum += elt;
  }
  return sum;
  // An even better way to write this would be:
  // return std::accumulate(v.begin(), v.end(), 0);
}
</pre>
<h2>See</h2>
<ul>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es71-prefer-a-range-for-statement-to-a-for-statement-when-there-is-a-choice">C++ Core Guidelines - ES.71</a> - Prefer a range-for-statement to a for-statement when there is a choice</li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#p3-express-intent">C++ Core Guidelines - P.3</a> - Express intent</li>
</ul>
