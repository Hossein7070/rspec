<p>When used as a type specifier in a declaration, &lt;code&gt;auto&lt;/code&gt; allows the compiler to deduce the type of a variable based on the type of the initialization expression.</p>
<p>In the following 2 cases:</p>
<ul>
<li>When the spelling of the initialization expression leaves no ambiguity on the type of the declared variable. This includes initializations using &lt;code&gt;new&lt;/code&gt;, template factory functions especially for smart pointers and cast expressions.</li>
<li>When declaring an &lt;code&gt;std::iterator&lt;/code&gt;, a &lt;code&gt;std::r&lt;/code&gt;&lt;code&gt;everse_iterator&lt;/code&gt;, a &lt;code&gt;std::c&lt;/code&gt;&lt;code&gt;onst_iterator&lt;/code&gt; or a &lt;code&gt;std::c&lt;/code&gt;&lt;code&gt;onst_reverse_iterator&lt;/code&gt;. This includes widely used patterns, especially in the context of loops.</li>
</ul>
<p>&lt;code&gt;auto&lt;/code&gt; should be used as it makes the code easier to read</p>
<h2>Noncompliant Code Example</h2>
<pre>
#include &lt;memory&gt;
#include &lt;vector&gt;

class C {};
class LongAndBoringClassName : public C {};

void f() {
  LongAndBoringClassName *newClass1 = new LongAndBoringClassName(); // Noncompliant
  LongAndBoringClassName *newClass2 = new LongAndBoringClassName(); // Noncompliant

  std::unique_ptr&lt;LongAndBoringClassName&gt; newClass3 = std::make_unique&lt;LongAndBoringClassName&gt;(); // Noncompliant
  std::shared_ptr&lt;LongAndBoringClassName&gt; newClass4 = std::make_shared&lt;LongAndBoringClassName&gt;(); // Noncompliant

  C* c = new LongAndBoringClassName(); // Compliant
  LongAndBoringClassName *newClass5 = static_cast&lt;ongAndBoringClassName*&gt;(c); // Noncompliant

  using MyVector = std::vector&lt;LongAndBoringClassName&gt;;
  MyVector u(10);
  for( MyVector::iterator it = u.begin(); it != u.end(); ++it) // Noncompliant
  {}
}
</pre>
<h2>Compliant Solution</h2>
<pre>
#include &lt;memory&gt;
#include &lt;vector&gt;

class C {};
class LongAndBoringClassName : public C {};

void f() {
  auto newClass1 = new LongAndBoringClassName(); // Compliant
  auto *newClass2 = new LongAndBoringClassName(); // Compliant

  auto newClass3 = std::make_unique&lt;LongAndBoringClassName&gt;(); // Compliant
  auto newClass4 = std::make_shared&lt;LongAndBoringClassName&gt;(); // Compliant

  C* c = new LongAndBoringClassName(); // Compliant
  auto newClass5 = static_cast&lt;LongAndBoringClassName*&gt;(c); // Compliant

  using MyVector = std::vector&lt;LongAndBoringClassName&gt;;
  MyVector u(10);
  for( auto it = u.begin(); it != u.end(); ++it) // Compliant
  {}
}
</pre>
<h2>Exceptions</h2>
<ul>
<li>In a declaration, if the initialization expression is between curly braces, then the intended explicit type of the declaration should not be replaced by auto because the deduced type would be &lt;code&gt;std::initializer_list&lt;/code&gt;.</li>
<li>If the type of declaration is builtin, there is no need to replace it by &lt;code&gt;auto&lt;/code&gt; as it will not make the code more concise or more readable.</li>
<li>If an iterator is declared through a &lt;code&gt;typedef&lt;/code&gt;, readability is already addressed.</li>
</ul>
<pre>
#include &lt;memory&gt;
#include &lt;vector&gt;

class LongAndBoringClassName {};
class D {
public:
  D(int) {}
};

void f() {
  D d = {1}; // Compliant

  int *i = new int(1); // Compliant

  using MyVector = std::vector&lt;LongAndBoringClassName&gt;;
  using MyIterator = MyVector::iterator;
  MyVector v(10);
  for( MyIterator it = v.begin(); it != v.end(); ++it) // Compliant
  {}
}
</pre>
<h2>See</h2>
<ul>
<li><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es11-use-auto-to-avoid-redundant-repetition-of-type-names">C++ Core Guidelines - ES.11</a>&nbsp;- Use auto to avoid redundant repetition of type names</li>
</ul>
