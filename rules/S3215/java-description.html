<p>Needing to cast from an &lt;code&gt;interface&lt;/code&gt; to a concrete type indicates that something is wrong with the abstractions in use, likely that something is missing from the &lt;code&gt;interface&lt;/code&gt;. Instead of casting to a discrete type, the missing functionality should be added to the &lt;code&gt;interface&lt;/code&gt;. Otherwise there is the risk of runtime exceptions.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public interface MyInterface {
  void doStuff();
}

public class MyClass1 implements MyInterface {
  int data;
  public void DoStuff()  {
    // TODO...
  }
}

public static class DowncastExampleProgram {
  static void EntryPoint(MyInterface interfaceRef) {
    MyClass1 class1 = (MyClass1)interfaceRef;  // Noncompliant
    int privateData = class1.data;
  }
}
</pre>
<h2>Exceptions</h2>
<p>Casting to &lt;code&gt;Object&lt;/code&gt; doesnâ€™t raise an issue, because it can never fail.</p>
<pre>
static void EntryPoint(IMyInterface interfaceRef)
{
  Object o = (Object)interfaceRef;
  ...
}
</pre>
