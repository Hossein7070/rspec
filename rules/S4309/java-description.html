<p>Collection classes from the &lt;code&gt;java.util.concurrent&lt;/code&gt; package have their own concurrency control mechanisms. A concurrent collection is thread-safe, but not governed by a single exclusion lock, therefore using an instance of such a class for synchronization is, at best unnecessary and at worst likely to have unintended consequences.</p>
<p>This rule raises an issue when a synchronization lock is used on an instance of one of the collection classes from the &lt;code&gt;java.util.concurrent&lt;/code&gt; package.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Foo {
  private ConcurrentHashMap&lt;String,String&gt; map = new ConcurrentHashMap&lt;&gt;();

  public void bar() {
    synchronized(map) {  // Noncompliant
      map.put("foo", "bar");
    }
    // Do something ...
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public class Foo {
  private ConcurrentHashMap&lt;String,String&gt; map = new ConcurrentHashMap&lt;&gt;();

  public void bar() {
    map.put("foo", "bar");
    // Do something ...
  }
}
</pre>
