<p>Deserializing objects is security-sensitive. For example, it has led in the past to the following vulnerabilities:</p>
<ul>
<li><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-10654">CVE-2018-10654</a>: Hazelcast Library: Java deserialization vulnerability</li>
<li><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-1000058">CVE-2018-1000058</a>: Jenkins Pipeline: arbitrary code execution vulnerability</li>
</ul>
<p>Object deserialization from an untrusted source can lead to unexpected code execution. &lt;code&gt;ObjectInputStream&lt;/code&gt; doesn’t provide a way to apply rules on its &lt;code&gt;InputStream&lt;/code&gt; argument. Knowing that all serializable classes in the scope of the classloader will be deserialized, there is a possibility that malicious code could be executed during the deserialization phase even if, in the end, a &lt;code&gt;ClassCastException&lt;/code&gt; will be raised.</p>
<p>Deserialization takes a stream of bits and turns it into an object. If the stream contains the type of object you expect, all is well. But if you’re deserializing untrusted input, and an attacker has inserted some other type of object, you’re in trouble. Why? There are a few different attack scenarios, but one widely-documented one goes like this: Deserialization first instantiates an &lt;code&gt;Object&lt;/code&gt;, then uses the  &lt;code&gt;readObject&lt;/code&gt; method to populate it. If the attacker has overridden &lt;code&gt;readObject&lt;/code&gt; then he is entirely in control of what code executes during that process. It is only after &lt;code&gt;readObject&lt;/code&gt; has completed that your newly-minted &lt;code&gt;Object&lt;/code&gt; can be cast to the type you expected. A &lt;code&gt;ClassCastException&lt;/code&gt; or &lt;code&gt;ClassNotFoundException&lt;/code&gt; will be thrown, but at that point it’s too late.</p>
<h2>Ask Yourself Whether</h2>
<ul>
<li>an attacker could have tampered with the source provided to the deserialization function.</li>
<li>you are using an unsafe deserialization function. See the <strong>Recommended Secure Coding Practices</strong> for examples of safe libraries.</li>
</ul>
<p>You are at risk if you answered yes to any of those questions.</p>
<h2>Recommended Secure Coding Practices</h2>
<p>To prevent insecure deserialization, you should either use look-ahead deserialization (pre-Java 9) or a filter to make sure you’re dealing with the correct type of object <em>before</em> you act on it.</p>
<p>Several third-party libraries offer look-ahead deserialization, including:</p>
<ul>
<li>ikkisoft’s &lt;code&gt;SerialKiller&lt;/code&gt;</li>
<li>Apache Commons Class IO’s &lt;code&gt;ValidatingObjectInputStream&lt;/code&gt;</li>
<li>contrast-rO0’s &lt;code&gt;SafeObjectInputStream&lt;/code&gt;</li>
</ul>
<p>Note that it is possible to set a deserialization filter at the level of the JVM, but relying on that requires that your environment be configured perfectly. Every time. Additionally, such a filter may have unwanted impacts on other applications in the environment. On the other hand, setting a filter as close as possible to the deserialization that uses it allows you to specify a very narrow, focused filter.</p>
<p>You should also limit access to the serialized source. For example:</p>
<ul>
<li>if it is a file, restrict the access to it.</li>
<li>if it comes from the network, restrict who has access to the process, such as with a Firewall or by authenticating the sender first.</li>
</ul>
<h2>See</h2>
<ul>
<li><a href="https://www.owasp.org/index.php/Deserialization_of_untrusted_data">OWASP - Deserialization of untrusted data</a></li>
<li><a href="https://www.owasp.org/index.php/Top_10-2017_A8-Insecure_Deserialization">OWASP Top 10 2017 Category A8</a> - Insecure Deserialization</li>
<li><a href="https://cwe.mitre.org/data/definitions/502.html">MITRE, CWE-502</a> - Deserialization of Untrusted Data</li>
<li>Derived from FindSecBugs rule <a href="https://find-sec-bugs.github.io/bugs.htm#OBJECT_DESERIALIZATION">OBJECT_DESERIALIZATION </a></li>
</ul>
