<p>Making an operator a convenience wrapper around an existing function or method provides additional flexibility to users in how the functionality is called and in what options are passed in.</p>
<p>This rule raises an issue when the function that defines the operation of a operator consists of something other than a single function call.</p>
<h2>Noncompliant Code Example</h2>
<pre>
infix operator &gt;&lt; { associativity right precedence 90 }
func &gt;&lt; (left: Double, right: Double) -&gt; Double {  // Noncompliant
  let leftD = (left % 1) * 100
  let rightD = (right % 1) * 100
  let leftW = (left - leftD) / 100
  let rightW = (right - rightD) / 100
  return (leftD + leftW) * (rightD + rightW)
}
</pre>
<h2>Compliant Solution</h2>
<pre>
infix operator &gt;&lt; { associativity right precedence 90 }
func &gt;&lt; (left: Double, right: Double) -&gt; Double {
  return fubar(left, right)
}

func fubar(left: Double, right: Double) -&gt; Double {
  let leftD = (left % 1) * 100
  let rightD = (right % 1) * 100
  let leftW = (left - leftD) / 100
  let rightW = (right - rightD) / 100
  return (leftD + leftW) * (rightD + rightW)
}
</pre>
<h2>Exceptions</h2>
<p>Operators that end with &lt;code&gt;=&lt;/code&gt; are expected to update their left-hand operands, and are therefore ignored.</p>
<pre>
func **= (inout p1:Int, p2:Int) {
    p1 = p1 ** p2
}
</pre>
