When a class with <code>virtual</code> methods but no <code>virtual</code> destructor is used as a base class, surprises can occur if pointers to instances of this class are used. Specifically, if  an instance of a derived class is assigned to a base class pointer, and <code>delete</code> is called, only the base class destructor will be invoked, so the object will only be partially destroyed. The resulting memory leak could eventually tie up enough resources to cause a denial of service.

If it is not expected for base class pointers to be deleted, then the destructor should be made <code>protected</code> to avoid such a misuse.


== Noncompliant Code Example

----
class Base { // Noncompliant: no destructor is supplied, and the default version is not virtual
public:
  Base() {}
  virtual void doSomething() {}
};
----


== Compliant Solution

----
class Base {
public:
  Base() {}
  virtual ~Base() = default;
  virtual void doSomething() {}
};
----


== See

* https://www.securecoding.cert.org/confluence/x/UQBO[CERT, OOP52-CPP.] - Do not delete a polymorphic object without a virtual destructor
* http://www.gotw.ca/publications/mill18.htm[Virtuality article]
* https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#c35-a-base-class-destructor-should-be-either-public-and-virtual-or-protected-and-nonvirtual[C++ Core Guidelines C.35] A base class destructor should be either public and virtual, or protected and nonvirtual
* https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#c127-a-class-with-a-virtual-function-should-have-a-virtual-or-protected-destructor[C++ Core Guidelines C.127] A class with a virtual function should have a virtual or protected destructor

