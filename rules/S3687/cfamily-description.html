<p>Except for interactions with &lt;code&gt;extern volatile&lt;/code&gt; variables provided by libraries, C/C++ programmers should consider &lt;code&gt;volatile&lt;/code&gt; an esoteric feature that is best avoided. In most cases, it is used in an attempt to provide atomicity, memory ordering, or inter-thread synchronization, but &lt;code&gt;volatile&lt;/code&gt; does not provide those guarantees. It is only really needed for the kind of low-level code found in kernels or embedded software, i.e. using memory-mapped I/O registers to manipulate hardware directly.</p>
<p>According to the C standard:
{quote}
&lt;code&gt;volatile&lt;/code&gt; is a hint to the implementation to avoid aggressive optimization involving the object because the value of the object might be changed by means undetectable by an implementation.
{quote}</p>
<p>Only C11/C++11 "atomic types" are free from data races.</p>
<p>This rule raises an issue when a &lt;code&gt;volatile&lt;/code&gt; type is declared.</p>
<h2>Noncompliant Code Example</h2>
<pre>
volatile int counter; // Noncompliant
User * volatile vpUser; // Noncompliant; pointer is volatile
User volatile * pvUser;  // Compliant; User instance is volatile, not the pointer
</pre>
<h2>Compliant Solution</h2>
<pre>
atomic_int counter;
std::atomic&lt;User*&gt; vpUser;
User volatile * pvUser;
</pre>
