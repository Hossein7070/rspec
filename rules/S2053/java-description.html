<p>In cryptography, "salt" is extra piece of data which is included in a hashing algorithm. It makes dictionary attacks more difficult. Using a cryptographic hash function without an unpredictable salt increases the likelihood that an attacker will be able to successfully guess a hashed value such as a password with a dictionary attack.</p>
<p>This rule raises an issue when a hashing function which has been specifically designed for hashing sensitive data, such as pbkdf2, is used with a non-random, reused or too short salt value. It does not raise an issue on base hashing algorithms such as sha1 or md5 as these are often used for other purposes.</p>
<h2>Recommended Secure Coding Practices</h2>
<ul>
<li>use hashing functions generating their own salt or generate a long random salt of at least 32 bytes.</li>
<li>the salt is at least as long as the resulting hash value.</li>
<li>provide the salt to a safe hashing function such as PBKDF2.</li>
<li>save both the salt and the hashed value in the relevant database record; during future validation operations, the salt and hash can then be retrieved from the database. The hash is recalculated with the stored salt and the value being validated, and the result compared to the stored hash.</li>
</ul>
<h2>Noncompliant Code Example</h2>
<p>Using &lt;code&gt;javax.crypto.spec.PBEKeySpec&lt;/code&gt;</p>
<pre>
import java.security.SecureRandom;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;

public class MyHash {

    public byte[] hash(String password, int iterationCount, int keyLength) throws Exception {
        SecretKeyFactory factory = null;
        byte [] salt = null;
        PBEKeySpec spec = null;
        factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA512");

        salt = password.getBytes();  // Noncompliant; password should not be used as salt as it makes it predictable
        spec = new PBEKeySpec(password.toCharArray(), salt, iterationCount, keyLength);

        salt = "hardcoded salt".getBytes();  // Noncompliant; salt is hardcoded
        spec = new PBEKeySpec(password.toCharArray(), salt, iterationCount, keyLength);

        SecureRandom random = new SecureRandom();
        salt = new byte[8]; // Noncompliant; salt too short (should be at least 32 bytes, not 8)
        random.nextBytes(salt);
        spec = new PBEKeySpec(password.toCharArray(), salt, iterationCount, keyLength);

        salt = new byte[32]; // Noncompliant; the salt is not initialized with a random value
        spec = new PBEKeySpec(password.toCharArray(), salt, iterationCount, keyLength);

        byte[] hash = factory.generateSecret(spec).getEncoded();
        return hash;
    }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
    public byte[] hash(String password, int iterationCount, int keyLength) throws Exception {
        SecretKeyFactory factory = null;
        byte [] salt = null;
        PBEKeySpec spec = null;
        factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA512");
        SecureRandom random = new SecureRandom();
        salt = new byte[32];
        random.nextBytes(salt);
        spec = new PBEKeySpec(password.toCharArray(), salt, iterationCount, keyLength);
        byte[] hash = factory.generateSecret(spec).getEncoded();
        return hash;
    }
</pre>
<h2>See</h2>
<ul>
<li><a href="https://www.owasp.org/index.php/Top_10-2017_A3-Sensitive_Data_Exposure">OWASP Top 10 2017 Category A3</a> - Sensitive Data Exposure</li>
<li><a href="http://cwe.mitre.org/data/definitions/759.html">MITRE, CWE-759</a> - Use of a One-Way Hash without a Salt</li>
<li><a href="http://cwe.mitre.org/data/definitions/760.html">MITRE, CWE-760</a> - Use of a One-Way Hash with a Predictable Salt</li>
<li><a href="https://www.sans.org/top25-software-errors/#cat3">SANS Top 25</a> - Porous Defenses</li>
</ul>
