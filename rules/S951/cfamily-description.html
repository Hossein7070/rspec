<p>Assigning between objects that have an overlap in their physical storage leads to undefined behaviour.</p>
<h2>Noncompliant Code Example</h2>
<pre>
struct s
{
  int16_t m1 [ 32 ];
};

struct t
{
  int32_t m2;
  struct s m3;
};

void fn ( )
{
  union
  {
    struct s u1;
    struct t u2;
  } a;
  a.u2.m3 = a.u1; // Noncompliant
}
</pre>
<h2>See</h2>
<ul>
<li>MISRA C:2004, 18.2</li>
<li>MISRA C++:2008, 0-2-1</li>
</ul>
