<p>This rule raises an issue when an iteration over the items of a &lt;code&gt;Collection&lt;/code&gt; is performed on a super-type of the type handled by the &lt;code&gt;Collection&lt;/code&gt;.</p>
<p>Relying on &lt;code&gt;Object&lt;/code&gt; or any classes between &lt;code&gt;Object&lt;/code&gt; and the real class handled by the &lt;code&gt;Collection&lt;/code&gt; is not recommended. While itâ€™s accepted by the language, this practice reduces readability of the code and forces to down-cast the item of the &lt;code&gt;Collection&lt;/code&gt; to be able to call a method on it while simply using the correct type in the iteration makes things more clear and simple.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public Collection&lt;Person&gt; getPersons() { ... }

for (Object item : getPersons()) { // Noncompliant
  Person person = (Person) item; // Noncompliant; it's required to down-cast to the to correct type to use "item"
  person.getAdress();
}
</pre>
<h2>Compliant Solution</h2>
<pre>
for (Person person : getPersons()) { // Compliant
  person.getAddress() ;
}
</pre>
