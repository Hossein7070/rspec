<p>Memory allocated dynamically with &lt;code&gt;calloc(…​)&lt;/code&gt;, &lt;code&gt;malloc(…​)&lt;/code&gt;, &lt;code&gt;realloc(…​)&lt;/code&gt; or &lt;code&gt;new&lt;/code&gt; should be released when it’s not needed anymore. Failure to do so will result in a memory leak that could bring the box to its knees.</p>
<p>This rule raises an issue when memory is allocated and not freed in the same function. Allocated memory is ignored if a pointer to it is &lt;code&gt;return&lt;/code&gt;ed to the caller or stored in a structure that’s external to the function.</p>
<h2>Noncompliant Code Example</h2>
<pre>
int fun() {
  char* name = (char *) malloc (size);
  if (!name) {
    return 1;
  }
  // ...
  return 0; // Noncompliant, memory pointed by "name" has not been released
}
</pre>
<h2>Compliant Solution</h2>
<pre>
int fun() {
  char* name = (char *) malloc (size);
  if (!name) {
    return 1;
  }
  // ...
  free(name);
  return 0;
}
</pre>
<h2>See</h2>
<ul>
<li><a href="https://cwe.mitre.org/data/definitions/401.html">MITRE, CWE-401</a> - Improper Release of Memory Before Removing Last Reference ('Memory Leak')</li>
<li><a href="https://www.securecoding.cert.org/confluence/x/twE">MEM00-C.</a> - Allocate and free memory in the same module, at the same level of abstraction</li>
<li><a href="https://www.securecoding.cert.org/confluence/x/vQE">CERT, MEM31-C.</a> - Free dynamically allocated memory when no longer needed</li>
</ul>
