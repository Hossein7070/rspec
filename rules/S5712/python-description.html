<p>In Python, special methods corresponding to numeric operators, rich comparison operators and the &lt;code&gt;_\_length_hint\_\_&lt;/code&gt; method should return &lt;code&gt;NotImplemented&lt;/code&gt; when the operation is not supported. These methods should not raise &lt;code&gt;NotImplementedError&lt;/code&gt; as callers don’t expect it and won’t catch this exception.</p>
<p>For example &lt;code&gt;A + B&lt;/code&gt; is equivalent to calling &lt;code&gt;A._\_add\__(B)&lt;/code&gt;. If this binary operation is not supported by class A, &lt;code&gt;A.\__add\__(B)&lt;/code&gt; should return &lt;code&gt;NotImplemented&lt;/code&gt;. The interpreter will then try the reverse operation, i.e. &lt;code&gt;B.\__radd\_\_(A)&lt;/code&gt;. This enables adding new operations by changing only one class instead of two.</p>
<p>This rule raises an issue when one of the following methods raises &lt;code&gt;NotImplementedError&lt;/code&gt; instead of returning &lt;code&gt;NotImplemented&lt;/code&gt;:</p>
<ul>
<li>_\_lt\_\_(self, other)</li>
<li>_\_le\_\_(self, other)</li>
<li>_\_eq\_\_(self, other)</li>
<li>_\_ne\_\_(self, other)</li>
<li>_\_gt\_\_(self, other)</li>
<li>_\_ge\_\_(self, other)</li>
<li>_\_add\_\_(self, other)</li>
<li>_\_sub\_\_(self, other)</li>
<li>_\_mul\_\_(self, other)</li>
<li>_\_matmul\_\_(self, other)</li>
<li>_\_truediv\_\_(self, other)</li>
<li>_\_floordiv\_\_(self, other)</li>
<li>_\_mod\_\_(self, other)</li>
<li>_\_divmod\_\_(self, other)</li>
<li>_\_pow\_\_(self, other[, modulo])</li>
<li>_\_lshift\_\_(self, other)</li>
<li>_\_rshift\_\_(self, other)</li>
<li>_\_and\_\_(self, other)</li>
<li>_\_xor\_\_(self, other)</li>
<li>_\_or\_\_(self, other)</li>
<li>_\_radd\_\_(self, other)</li>
<li>_\_rsub\_\_(self, other)</li>
<li>_\_rmul\_\_(self, other)</li>
<li>_\_rmatmul\_\_(self, other)</li>
<li>_\_rtruediv\_\_(self, other)</li>
<li>_\_rfloordiv\_\_(self, other)</li>
<li>_\_rmod\_\_(self, other)</li>
<li>_\_rdivmod\_\_(self, other)</li>
<li>_\_rpow\_\_(self, other[, modulo])</li>
<li>_\_rlshift\_\_(self, other)</li>
<li>_\_rrshift\_\_(self, other)</li>
<li>_\_rand\_\_(self, other)</li>
<li>_\_rxor\_\_(self, other)</li>
<li>_\_ror\_\_(self, other)</li>
<li>_\_iadd\_\_(self, other)</li>
<li>_\_isub\_\_(self, other)</li>
<li>_\_imul\_\_(self, other)</li>
<li>_\_imatmul\_\_(self, other)</li>
<li>_\_itruediv\_\_(self, other)</li>
<li>_\_ifloordiv\_\_(self, other)</li>
<li>_\_imod\_\_(self, other)</li>
<li>_\_ipow\_\_(self, other[, modulo])</li>
<li>_\_ilshift\_\_(self, other)</li>
<li>_\_irshift\_\_(self, other)</li>
<li>_\_iand\_\_(self, other)</li>
<li>_\_ixor\_\_(self, other)</li>
<li>_\_ior\_\_(self, other)</li>
<li>_\_length_hint\_\_(self)</li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
class MyClass:
    def __add__(self, other):
        raise NotImplementedError()  # Noncompliant
    def __radd__(self, other):
        raise NotImplementedError()  # Noncompliant

class MyOtherClass:
    def __add__(self, other):
        return 42
    def __radd__(self, other):
        return 42

MyClass() + MyOtherClass()  # This will raise NotImplementedError
</pre>
<h2>Compliant Solution</h2>
<pre>
class MyClass:
    def __add__(self, other):
        return NotImplemented
    def __radd__(self, other):
        return NotImplemented

class MyOtherClass:
    def __add__(self, other):
        return 42
    def __radd__(self, other):
        return 42

MyClass() + MyOtherClass()  # This returns 42
</pre>
<h2>See</h2>
<ul>
<li>Python documentation - <a href="https://docs.python.org/3/library/constants.html#NotImplemented">Built-in Constants - NotImplemented</a></li>
<li>Python documentation - <a href="https://docs.python.org/3/library/numbers.html#implementing-the-arithmetic-operations">Implementing the arithmetic operations</a></li>
</ul>
