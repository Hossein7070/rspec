<p>Because &lt;code&gt;IEnumerable&lt;/code&gt;s are lazy-evaluated, each iteration causes a re-retrieval of the values, which could involve considerable overhead. For instance, when the &lt;code&gt;IEnumerable&lt;/code&gt; is backed by a database, each iteration requires an additional round of database interactions. For that reason, any time the set represented by an &lt;code&gt;IEnumerable&lt;/code&gt; must be iterated multiple times, it should first be converted to a &lt;code&gt;List&lt;/code&gt;, which will retrieve the values and store them in memory. From that point they can be iterated as often as needed without an additional performance hit.</p>
<p>This rule raises an issue for each iteration of an &lt;code&gt;IEnumerable&lt;/code&gt; after the first one.</p>
<h2>Noncompliant Code Example</h2>
<pre>
IEnumerable&lt;int&gt; numbers = GetNumbers();

var count = numbers.Count(); // causes an iteration
var last = numbers.Last(); // Noncompliant; causes an iteration

foreach(var x in numbers)  // Noncompliant
{
  // ...
}
</pre>
<pre>
List&lt;int&gt; numbers = GetNumbers().ToList(); // iterable to your heart's content

var count = numbers.Count();
var last = numbers.[count -1];

foreach(var x in numbers)
{
  // ...
}
</pre>
