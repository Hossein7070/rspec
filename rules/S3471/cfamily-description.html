<p>In a base class, &lt;code&gt;virtual&lt;/code&gt; indicates that a function can be overridden. In a derived class, it indicates an override. But given the specifierâ€™s dual meaning, it would be both clearer and more sound to use derived class-specific specifiers instead: &lt;code&gt;override&lt;/code&gt; or &lt;code&gt;final&lt;/code&gt;.</p>
<ul>
<li>&lt;code&gt;final&lt;/code&gt; indicates a function &lt;code&gt;override&lt;/code&gt; that cannot itself be overridden. The compiler will issue a warning if the signature does not match the signature of a base-class &lt;code&gt;virtual&lt;/code&gt; function.</li>
<li>&lt;code&gt;override&lt;/code&gt; indicates that a function is intended to override a base-class function. The compiler will issue a warning if this is not the case. It is redundant in combination with &lt;code&gt;final&lt;/code&gt;.</li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
class Counter {
protected:
  int c = 0;
public:
  virtual void count() {
    c++;
  }
};

class FastCounter: public Counter {
public:
  virtual void count() {  // Noncompliant
    c += 2;
  }
};
</pre>
<h2>Compliant Solution</h2>
<pre>
class Counter {
protected:
  int c = 0;
public:
  virtual void count() {
    c++;
  }
};

class FastCounter: public Counter {
public:
  void count() override {
    c += 2;
  }
};
</pre>
<p>or</p>
<pre>
class Counter {
protected:
  int c = 0;
public:
  virtual void count() {
    c++;
  }
};

class FastCounter: public Counter {
public:
  void count() final {
    c += 2;
  }
};
</pre>
<h3>See also</h3>
<ul>
<li>S1016</li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#c128-virtual-functions-should-specify-exactly-one-of-virtual-override-or-final">C++ Core Guidelines C.128</a>: Virtual functions should specify exactly one of virtual, override, or final</li>
</ul>
