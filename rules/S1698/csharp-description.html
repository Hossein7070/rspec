<p>Using the equality &lt;code&gt;==&lt;/code&gt; and inequality &lt;code&gt;!=&lt;/code&gt; operators to compare two objects generally works. The operators can be overloaded, and therefore the comparison can resolve to the appropriate method. However, when the operators are used on interface instances, then &lt;code&gt;==&lt;/code&gt; resolves to reference equality, which may result in unexpected behavior if implementing classes override &lt;code&gt;Equals&lt;/code&gt;. Similarly, when a class overrides &lt;code&gt;Equals&lt;/code&gt;, but instances are compared with non-overloaded &lt;code&gt;==&lt;/code&gt;, there is a high chance that value comparison was meant instead of the reference one.</p>
<h2>Noncompliant Code Example</h2>
<pre>
public interface IMyInterface
{
}

public class MyClass : IMyInterface
{
    public override bool Equals(object obj)
    {
        //...
    }
}

public class Program
{
    public static void Method(IMyInterface instance1, IMyInterface instance2)
    {
        if (instance1 == instance2) // Noncompliant, will do reference equality check, but was that intended? MyClass overrides Equals.
        {
            Console.WriteLine("Equal");
        }
    }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public interface IMyInterface
{
}

public class MyClass : IMyInterface
{
    public override bool Equals(object obj)
    {
        //...
    }
}

public class Program
{
    public static void Method(IMyInterface instance1, IMyInterface instance2)
    {
        if (object.Equals(instance1, instance2)) // object.Equals checks for null and then calls the instance based Equals, so MyClass.Equals
        {
            Console.WriteLine("Equal");
        }
    }
}
</pre>
<h2>Exceptions</h2>
<p>The rule does not report on comparisons of &lt;code&gt;System.Type&lt;/code&gt; instances and on comparisons inside &lt;code&gt;Equals&lt;/code&gt; overrides.
It also does not raise an issue when one of the operands is &lt;code&gt;null&lt;/code&gt; nor when one of the operand is cast to &lt;code&gt;object&lt;/code&gt; (because in this case we want to ensure reference equality even if some &lt;code&gt;==&lt;/code&gt; overload is present).</p>
<h2>See</h2>
<ul>
<li><a href="http://cwe.mitre.org/data/definitions/595.html">MITRE, CWE-595</a> - Comparison of Object References Instead of Object Contents</li>
<li><a href="http://cwe.mitre.org/data/definitions/597.html">MITRE, CWE-597</a> - Use of Wrong Operator in String Comparison</li>
<li><a href="https://www.securecoding.cert.org/confluence/x/wwD1AQ">CERT, EXP03-J.</a> - Do not use the equality operators when comparing values of boxed primitives</li>
<li><a href="https://www.securecoding.cert.org/confluence/x/8AEqAQ">CERT, EXP50-J.</a> - Do not confuse abstract object equality with reference equality</li>
</ul>
