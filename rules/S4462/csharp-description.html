<p>Making blocking calls to &lt;code&gt;async&lt;/code&gt; methods transforms something that was intended to be asynchronous into a synchronous block. Doing so can cause deadlocks and unexpected blocking of context threads.</p>
<p>According to the MSDN documentation:
{quote}
The root cause of this deadlock is due to the way &lt;code&gt;await&lt;/code&gt; handles contexts. By default, when an incomplete &lt;code&gt;Task&lt;/code&gt; is awaited, the current “context” is captured and used to resume the method when the &lt;code&gt;Task&lt;/code&gt; completes. This “context” is the current &lt;code&gt;SynchronizationContext&lt;/code&gt; unless it’s null, in which case it’s the current &lt;code&gt;TaskScheduler&lt;/code&gt;. GUI and ASP.NET applications have a &lt;code&gt;SynchronizationContext&lt;/code&gt; that permits only one chunk of code to run at a time. When the &lt;code&gt;await&lt;/code&gt; completes, it attempts to execute the remainder of the &lt;code&gt;async&lt;/code&gt; method within the captured context. But that context already has a thread in it, which is (synchronously) waiting for the &lt;code&gt;async&lt;/code&gt; method to complete. They’re each waiting for the other, causing a deadlock.
{quote}</p>
<p>||To Do This …||Instead of This …||Use This||
|Retrieve the result of a background task|&lt;code&gt;Task.Wait&lt;/code&gt;, &lt;code&gt;Task.Result&lt;/code&gt; or &lt;code&gt;Task.GetAwaiter.GetResult&lt;/code&gt;|&lt;code&gt;await&lt;/code&gt;|
|Wait for any task to complete|&lt;code&gt;Task.WaitAny&lt;/code&gt;|&lt;code&gt;await Task.WhenAny&lt;/code&gt;|
|Retrieve the results of multiple tasks|&lt;code&gt;Task.WaitAll&lt;/code&gt;|&lt;code&gt;await Task.WhenAll&lt;/code&gt;|
|Wait a period of time|&lt;code&gt;Thread.Sleep&lt;/code&gt;|&lt;code&gt;await Task.Delay&lt;/code&gt;|</p>
<h2>Noncompliant Code Example</h2>
<pre>
public static class DeadlockDemo
{
    private static async Task DelayAsync()
    {
        await Task.Delay(1000);
    }

    // This method causes a deadlock when called in a GUI or ASP.NET context.
    public static void Test()
    {
        // Start the delay.
        var delayTask = DelayAsync();
        // Wait for the delay to complete.
        delayTask.Wait(); // Noncompliant
    }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
public static class DeadlockDemo
{
    private static async Task DelayAsync()
    {
        await Task.Delay(1000);
    }

    public static async Task TestAsync()
    {
        // Start the delay.
        var delayTask = DelayAsync();
        // Wait for the delay to complete.
        await delayTask;
    }
}
</pre>
<h2>Exceptions</h2>
<ul>
<li>Main methods of Console Applications are not subject to this deadlock issue and so are ignored by this rule.</li>
<li>&lt;code&gt;Thread.Sleep&lt;/code&gt; is also ignored when it is used in a non-&lt;code&gt;async&lt;/code&gt; method.</li>
<li>Calls chained after &lt;code&gt;Task.Run&lt;/code&gt; or &lt;code&gt;Task.Factory.StartNew&lt;/code&gt; are ignored because they don’t suffer from this deadlock issue</li>
</ul>
<h2>See</h2>
<ul>
<li><a href="https://msdn.microsoft.com/en-us/magazine/jj991977.aspx">Async/Await - Best Practices in Asynchronous Programming</a></li>
</ul>
