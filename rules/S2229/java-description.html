<p>When using Spring proxies, calling a method in the same class (e.g. &lt;code&gt;this.aMethod()&lt;/code&gt;) with an incompatible &lt;code&gt;@Transactional&lt;/code&gt; requirement will result in runtime exceptions because Spring only "sees" the caller and makes no provisions for properly invoking the callee.</p>
<p>Therefore, certain calls should never be made within the same class:
||From||To||
| non-&lt;code&gt;@Transactional&lt;/code&gt; | MANDATORY, NESTED, REQUIRED, REQUIRES_NEW |
| MANDATORY | NESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW |
| NESTED | NESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW |
| NEVER | MANDATORY, NESTED, REQUIRED, REQUIRES_NEW |
| NOT_SUPPORTED | MANDATORY, NESTED, REQUIRED, REQUIRES_NEW |
| REQUIRED or &lt;code&gt;@Transactional&lt;/code&gt; | NESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW |
| REQUIRES_NEW | NESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW |
| SUPPORTS | MANDATORY, NESTED, NEVER, NOT_SUPPORTED, REQUIRED, REQUIRES_NEW |</p>
<h2>Noncompliant Code Example</h2>
<pre>
@Override
public void doTheThing() {
  // ...
  actuallyDoTheThing();  // Noncompliant
}

@Override
@Transactional
public void actuallyDoTheThing() {
  // ...
}
</pre>
